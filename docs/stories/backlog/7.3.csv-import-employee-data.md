# Story 7.3: Implement CSV Import for Employee Data

## Status

Draft

## Story

**As an** HR manager,
**I want** to import employees from CSV/Excel,
**so that** I don't manually enter 50+ employees.

## Acceptance Criteria

1. Import button on Employee List page
2. Upload CSV file (max 10MB)
3. CSV columns expected: Name, Personnummer, Email, Phone, Employment Date, Contract Type, Role, Department
4. Preview table shows first 10 rows
5. Column mapping: User maps CSV columns to system fields (auto-detected if headers match)
6. Date format selector (DD/MM/YYYY, YYYY-MM-DD, etc.)
7. **GPT-4 fuzzy role matching:** "Builder" → "construction_worker", "CEO" → "manager"
8. Validation: Highlight invalid rows (missing required fields, invalid personnummer)
9. "Skip invalid rows" checkbox
10. Import button processes valid rows, shows summary: "45 imported, 5 skipped"
11. Error log downloadable: "Row 12: Invalid personnummer format"
12. Role-based access: Only HR Manager, Admin, Owner can import

## Tasks / Subtasks

- [ ] Add import button to Employee List page
- [ ] Create CSV upload modal with drag-and-drop
- [ ] Implement CSV parsing (support CSV and Excel)
- [ ] Build column mapping interface with auto-detection
- [ ] Add date format selector
- [ ] Implement GPT-4 fuzzy role matching
- [ ] Build validation engine for required fields and data formats
- [ ] Create preview table with validation highlights
- [ ] Implement import processing with progress indicator
- [ ] Generate import summary and error log
- [ ] Add downloadable error log (CSV format)
- [ ] Test with various CSV formats and edge cases

## Dev Notes

**Import Flow:**

1. User uploads CSV file
2. System parses CSV and auto-detects columns
3. User maps columns to system fields (if needed)
4. User selects date format
5. System validates all rows and highlights errors
6. User confirms import (optionally skip invalid rows)
7. System processes import with AI role matching
8. System shows summary with error log

**CSV Import Modal:**

```typescript
// components/hr/import-employees-modal.tsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { ColumnMapper } from './column-mapper'
import { ImportPreview } from './import-preview'
import { ImportSummary } from './import-summary'

interface ImportEmployeesModalProps {
  isOpen: boolean
  onClose: () => void
}

type ImportStep = 'upload' | 'map' | 'preview' | 'processing' | 'summary'

export function ImportEmployeesModal({ isOpen, onClose }: ImportEmployeesModalProps) {
  const router = useRouter()
  const [step, setStep] = useState<ImportStep>('upload')
  const [file, setFile] = useState<File | null>(null)
  const [csvData, setCsvData] = useState<any[]>([])
  const [headers, setHeaders] = useState<string[]>([])
  const [columnMapping, setColumnMapping] = useState<Record<string, string>>({})
  const [dateFormat, setDateFormat] = useState('YYYY-MM-DD')
  const [skipInvalid, setSkipInvalid] = useState(true)
  const [importResult, setImportResult] = useState<any>(null)

  function handleFileUpload(e: React.ChangeEvent<HTMLInputElement>) {
    const uploadedFile = e.target.files?.[0]
    if (!uploadedFile) return

    // Validate file type
    if (!uploadedFile.name.endsWith('.csv') && !uploadedFile.name.endsWith('.xlsx')) {
      alert('Only CSV and Excel files are supported')
      return
    }

    // Validate file size (max 10MB)
    if (uploadedFile.size > 10 * 1024 * 1024) {
      alert('File size must be less than 10MB')
      return
    }

    setFile(uploadedFile)
    parseCSV(uploadedFile)
  }

  async function parseCSV(file: File) {
    const text = await file.text()
    const lines = text.split('\n').filter((line) => line.trim())

    if (lines.length === 0) {
      alert('CSV file is empty')
      return
    }

    // Parse headers
    const headerLine = lines[0]
    const parsedHeaders = parseCSVLine(headerLine)
    setHeaders(parsedHeaders)

    // Parse data rows
    const data = lines.slice(1).map((line, index) => {
      const values = parseCSVLine(line)
      const row: any = { _rowNumber: index + 2 } // +2 for header and 1-indexing
      parsedHeaders.forEach((header, i) => {
        row[header] = values[i] || ''
      })
      return row
    })
    setCsvData(data)

    // Auto-detect column mapping
    const autoMapping = autoDetectColumns(parsedHeaders)
    setColumnMapping(autoMapping)

    setStep('map')
  }

  function parseCSVLine(line: string): string[] {
    const result: string[] = []
    let current = ''
    let inQuotes = false

    for (let i = 0; i < line.length; i++) {
      const char = line[i]

      if (char === '"') {
        inQuotes = !inQuotes
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim())
        current = ''
      } else {
        current += char
      }
    }
    result.push(current.trim())

    return result
  }

  function autoDetectColumns(headers: string[]): Record<string, string> {
    const mapping: Record<string, string> = {}
    const systemFields = ['name', 'personnummer', 'email', 'phone', 'employmentDate', 'contractType', 'role', 'department']

    headers.forEach((header) => {
      const normalized = header.toLowerCase().replace(/[^a-z]/g, '')

      if (normalized.includes('name') || normalized.includes('namn')) {
        mapping[header] = 'name'
      } else if (normalized.includes('personnummer') || normalized.includes('ssn') || normalized.includes('pnr')) {
        mapping[header] = 'personnummer'
      } else if (normalized.includes('email') || normalized.includes('epost')) {
        mapping[header] = 'email'
      } else if (normalized.includes('phone') || normalized.includes('telefon') || normalized.includes('tel')) {
        mapping[header] = 'phone'
      } else if (normalized.includes('employment') || normalized.includes('anstallning') || normalized.includes('startdate')) {
        mapping[header] = 'employmentDate'
      } else if (normalized.includes('contract') || normalized.includes('anstallningsform')) {
        mapping[header] = 'contractType'
      } else if (normalized.includes('role') || normalized.includes('roll') || normalized.includes('title')) {
        mapping[header] = 'role'
      } else if (normalized.includes('department') || normalized.includes('avdelning')) {
        mapping[header] = 'department'
      }
    })

    return mapping
  }

  async function handleImport() {
    setStep('processing')

    try {
      const response = await fetch('/api/employees/import', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          data: csvData,
          columnMapping,
          dateFormat,
          skipInvalid
        })
      })

      const result = await response.json()
      setImportResult(result)
      setStep('summary')
      router.refresh()
    } catch (error) {
      console.error('Import failed:', error)
      alert('Import failed. Please try again.')
      setStep('preview')
    }
  }

  if (!isOpen) return null

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-lg w-full max-w-6xl max-h-[90vh] overflow-y-auto">
        {/* Header */}
        <div className="flex items-center justify-between p-6 border-b border-gray-200">
          <div>
            <h2 className="text-xl font-bold">Import Employees</h2>
            <p className="text-sm text-gray-600 mt-1">
              {step === 'upload' && 'Upload your CSV or Excel file'}
              {step === 'map' && 'Map columns to system fields'}
              {step === 'preview' && 'Preview and validate data'}
              {step === 'processing' && 'Processing import...'}
              {step === 'summary' && 'Import complete'}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600"
          >
            <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>

        {/* Content */}
        <div className="p-6">
          {step === 'upload' && (
            <div>
              <label className="flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100">
                <div className="flex flex-col items-center justify-center pt-5 pb-6">
                  <svg className="w-12 h-12 mb-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                  </svg>
                  <p className="mb-2 text-sm text-gray-500">
                    <span className="font-semibold">Click to upload</span> or drag and drop
                  </p>
                  <p className="text-xs text-gray-500">CSV or Excel (max 10MB)</p>
                </div>
                <input
                  type="file"
                  className="hidden"
                  accept=".csv,.xlsx"
                  onChange={handleFileUpload}
                />
              </label>

              <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <h3 className="font-medium text-blue-900 mb-2">Expected CSV Format:</h3>
                <p className="text-sm text-blue-800">
                  Name, Personnummer, Email, Phone, Employment Date, Contract Type, Role, Department
                </p>
                <p className="text-xs text-blue-700 mt-2">
                  You can map columns in the next step if your CSV has different headers.
                </p>
              </div>
            </div>
          )}

          {step === 'map' && (
            <ColumnMapper
              headers={headers}
              columnMapping={columnMapping}
              onMappingChange={setColumnMapping}
              dateFormat={dateFormat}
              onDateFormatChange={setDateFormat}
              onNext={() => setStep('preview')}
              onBack={() => setStep('upload')}
            />
          )}

          {step === 'preview' && (
            <ImportPreview
              data={csvData}
              columnMapping={columnMapping}
              dateFormat={dateFormat}
              skipInvalid={skipInvalid}
              onSkipInvalidChange={setSkipInvalid}
              onImport={handleImport}
              onBack={() => setStep('map')}
            />
          )}

          {step === 'processing' && (
            <div className="flex flex-col items-center justify-center py-12">
              <svg className="animate-spin h-12 w-12 text-blue-600 mb-4" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <p className="text-lg font-medium text-gray-900">Importing employees...</p>
              <p className="text-sm text-gray-600 mt-2">This may take a few moments</p>
            </div>
          )}

          {step === 'summary' && importResult && (
            <ImportSummary
              result={importResult}
              onClose={onClose}
            />
          )}
        </div>
      </div>
    </div>
  )
}
```

**Column Mapper Component:**

```typescript
// components/hr/column-mapper.tsx
'use client'

interface ColumnMapperProps {
  headers: string[]
  columnMapping: Record<string, string>
  onMappingChange: (mapping: Record<string, string>) => void
  dateFormat: string
  onDateFormatChange: (format: string) => void
  onNext: () => void
  onBack: () => void
}

const SYSTEM_FIELDS = [
  { value: 'name', label: 'Name', required: true },
  { value: 'personnummer', label: 'Personnummer', required: true },
  { value: 'email', label: 'Email', required: false },
  { value: 'phone', label: 'Phone', required: false },
  { value: 'employmentDate', label: 'Employment Date', required: true },
  { value: 'contractType', label: 'Contract Type', required: true },
  { value: 'role', label: 'Role', required: true },
  { value: 'department', label: 'Department', required: false }
]

const DATE_FORMATS = [
  { value: 'YYYY-MM-DD', label: 'YYYY-MM-DD (2024-01-15)', example: '2024-01-15' },
  { value: 'DD/MM/YYYY', label: 'DD/MM/YYYY (15/01/2024)', example: '15/01/2024' },
  { value: 'MM/DD/YYYY', label: 'MM/DD/YYYY (01/15/2024)', example: '01/15/2024' },
  { value: 'DD-MM-YYYY', label: 'DD-MM-YYYY (15-01-2024)', example: '15-01-2024' }
]

export function ColumnMapper({
  headers,
  columnMapping,
  onMappingChange,
  dateFormat,
  onDateFormatChange,
  onNext,
  onBack
}: ColumnMapperProps) {
  function handleMappingChange(csvColumn: string, systemField: string) {
    const newMapping = { ...columnMapping }

    // Remove previous mapping for this system field
    Object.keys(newMapping).forEach((key) => {
      if (newMapping[key] === systemField) {
        delete newMapping[key]
      }
    })

    // Add new mapping
    if (systemField) {
      newMapping[csvColumn] = systemField
    } else {
      delete newMapping[csvColumn]
    }

    onMappingChange(newMapping)
  }

  // Check if all required fields are mapped
  const requiredFieldsMapped = SYSTEM_FIELDS
    .filter((f) => f.required)
    .every((field) => Object.values(columnMapping).includes(field.value))

  return (
    <div>
      <div className="space-y-4 mb-6">
        <h3 className="font-medium text-gray-900">Map CSV Columns to System Fields</h3>

        {headers.map((header) => (
          <div key={header} className="flex items-center gap-4">
            <div className="flex-1">
              <label className="block text-sm font-medium text-gray-700 mb-1">
                CSV Column: <span className="text-blue-600">{header}</span>
              </label>
            </div>
            <div className="flex-1">
              <select
                value={columnMapping[header] || ''}
                onChange={(e) => handleMappingChange(header, e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 rounded-lg"
              >
                <option value="">-- Skip this column --</option>
                {SYSTEM_FIELDS.map((field) => (
                  <option key={field.value} value={field.value}>
                    {field.label} {field.required && '(required)'}
                  </option>
                ))}
              </select>
            </div>
          </div>
        ))}
      </div>

      {/* Date Format Selector */}
      <div className="p-4 bg-gray-50 rounded-lg mb-6">
        <label className="block text-sm font-medium text-gray-700 mb-2">
          Employment Date Format
        </label>
        <select
          value={dateFormat}
          onChange={(e) => onDateFormatChange(e.target.value)}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg"
        >
          {DATE_FORMATS.map((format) => (
            <option key={format.value} value={format.value}>
              {format.label}
            </option>
          ))}
        </select>
      </div>

      {/* Required Fields Warning */}
      {!requiredFieldsMapped && (
        <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg mb-6">
          <p className="text-sm text-yellow-800">
            Please map all required fields: Name, Personnummer, Employment Date, Contract Type, Role
          </p>
        </div>
      )}

      {/* Actions */}
      <div className="flex gap-3">
        <button
          onClick={onBack}
          className="flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
        >
          Back
        </button>
        <button
          onClick={onNext}
          disabled={!requiredFieldsMapped}
          className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300"
        >
          Next: Preview
        </button>
      </div>
    </div>
  )
}
```

**Import Preview Component:**

```typescript
// components/hr/import-preview.tsx
'use client'

import { useMemo } from 'react'

interface ImportPreviewProps {
  data: any[]
  columnMapping: Record<string, string>
  dateFormat: string
  skipInvalid: boolean
  onSkipInvalidChange: (skip: boolean) => void
  onImport: () => void
  onBack: () => void
}

export function ImportPreview({
  data,
  columnMapping,
  dateFormat,
  skipInvalid,
  onSkipInvalidChange,
  onImport,
  onBack
}: ImportPreviewProps) {
  // Validate all rows
  const validatedData = useMemo(() => {
    return data.map((row) => {
      const errors: string[] = []
      const mapped: any = {}

      // Map columns
      Object.entries(columnMapping).forEach(([csvColumn, systemField]) => {
        mapped[systemField] = row[csvColumn]
      })

      // Validate required fields
      if (!mapped.name || mapped.name.trim() === '') {
        errors.push('Name is required')
      }
      if (!mapped.personnummer || !/^\d{12}$/.test(mapped.personnummer.replace(/\D/g, ''))) {
        errors.push('Invalid personnummer (must be 12 digits)')
      }
      if (!mapped.employmentDate) {
        errors.push('Employment date is required')
      }
      if (!mapped.contractType) {
        errors.push('Contract type is required')
      }
      if (!mapped.role) {
        errors.push('Role is required')
      }

      // Validate email format (if provided)
      if (mapped.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(mapped.email)) {
        errors.push('Invalid email format')
      }

      return {
        ...row,
        _mapped: mapped,
        _errors: errors,
        _isValid: errors.length === 0
      }
    })
  }, [data, columnMapping])

  const validCount = validatedData.filter((row) => row._isValid).length
  const invalidCount = validatedData.length - validCount

  return (
    <div>
      {/* Stats */}
      <div className="grid grid-cols-3 gap-4 mb-6">
        <div className="p-4 bg-blue-50 rounded-lg">
          <p className="text-sm text-blue-600 font-medium">Total Rows</p>
          <p className="text-2xl font-bold text-blue-900">{validatedData.length}</p>
        </div>
        <div className="p-4 bg-green-50 rounded-lg">
          <p className="text-sm text-green-600 font-medium">Valid</p>
          <p className="text-2xl font-bold text-green-900">{validCount}</p>
        </div>
        <div className="p-4 bg-red-50 rounded-lg">
          <p className="text-sm text-red-600 font-medium">Invalid</p>
          <p className="text-2xl font-bold text-red-900">{invalidCount}</p>
        </div>
      </div>

      {/* Skip Invalid Checkbox */}
      {invalidCount > 0 && (
        <div className="p-4 bg-yellow-50 border border-yellow-200 rounded-lg mb-6">
          <label className="flex items-center gap-2 cursor-pointer">
            <input
              type="checkbox"
              checked={skipInvalid}
              onChange={(e) => onSkipInvalidChange(e.target.checked)}
              className="w-4 h-4"
            />
            <span className="text-sm text-yellow-800">
              Skip invalid rows and import only valid data ({validCount} rows)
            </span>
          </label>
        </div>
      )}

      {/* Preview Table (first 10 rows) */}
      <div className="border border-gray-200 rounded-lg overflow-hidden mb-6">
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Status</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Name</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Personnummer</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Role</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase">Errors</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {validatedData.slice(0, 10).map((row, index) => (
                <tr key={index} className={row._isValid ? '' : 'bg-red-50'}>
                  <td className="px-4 py-3 whitespace-nowrap">
                    {row._isValid ? (
                      <span className="text-green-600 font-medium">✓</span>
                    ) : (
                      <span className="text-red-600 font-medium">✗</span>
                    )}
                  </td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm">{row._mapped.name || '—'}</td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm">{row._mapped.personnummer || '—'}</td>
                  <td className="px-4 py-3 whitespace-nowrap text-sm">{row._mapped.role || '—'}</td>
                  <td className="px-4 py-3 text-sm text-red-600">
                    {row._errors.length > 0 ? row._errors.join(', ') : '—'}
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
        {validatedData.length > 10 && (
          <div className="p-3 bg-gray-50 text-center text-sm text-gray-600">
            Showing first 10 of {validatedData.length} rows
          </div>
        )}
      </div>

      {/* Actions */}
      <div className="flex gap-3">
        <button
          onClick={onBack}
          className="flex-1 px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50"
        >
          Back
        </button>
        <button
          onClick={onImport}
          disabled={invalidCount > 0 && !skipInvalid}
          className="flex-1 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300"
        >
          Import {skipInvalid && invalidCount > 0 ? `${validCount} Valid Rows` : 'All Rows'}
        </button>
      </div>
    </div>
  )
}
```

**Import API with AI Role Matching:**

```typescript
// app/api/employees/import/route.ts
import { NextResponse } from 'next/server'
import { withWorkspace } from '@/lib/auth/with-workspace'
import { checkPermission, Permission } from '@/lib/permissions/roles'
import { WorkspaceRole } from '@prisma/client'
import { prisma } from '@/lib/prisma'
import { encrypt } from '@/lib/encryption'
import OpenAI from 'openai'

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

export async function POST(request: Request) {
  return withWorkspace(async ({ workspaceId, userId, role }) => {
    checkPermission(role as WorkspaceRole, Permission.MANAGE_EMPLOYEES)

    const { data, columnMapping, dateFormat, skipInvalid } =
      await request.json()

    const results = {
      imported: 0,
      skipped: 0,
      errors: [] as Array<{ row: number; errors: string[] }>,
    }

    for (const [index, row] of data.entries()) {
      const rowNumber = row._rowNumber || index + 1

      try {
        // Map columns
        const mapped: any = {}
        Object.entries(columnMapping).forEach(([csvColumn, systemField]) => {
          mapped[systemField as string] = row[csvColumn]
        })

        // Validate required fields
        const validationErrors: string[] = []
        if (!mapped.name || mapped.name.trim() === '') {
          validationErrors.push('Name is required')
        }
        if (
          !mapped.personnummer ||
          !/^\d{12}$/.test(mapped.personnummer.replace(/\D/g, ''))
        ) {
          validationErrors.push('Invalid personnummer')
        }
        if (!mapped.employmentDate) {
          validationErrors.push('Employment date is required')
        }
        if (!mapped.contractType) {
          validationErrors.push('Contract type is required')
        }
        if (!mapped.role) {
          validationErrors.push('Role is required')
        }

        if (validationErrors.length > 0) {
          if (skipInvalid) {
            results.skipped++
            results.errors.push({ row: rowNumber, errors: validationErrors })
            continue
          } else {
            return NextResponse.json(
              { error: `Row ${rowNumber}: ${validationErrors.join(', ')}` },
              { status: 400 }
            )
          }
        }

        // Parse employment date
        const employmentDate = parseDate(mapped.employmentDate, dateFormat)
        if (!employmentDate) {
          const error = 'Invalid date format'
          if (skipInvalid) {
            results.skipped++
            results.errors.push({ row: rowNumber, errors: [error] })
            continue
          } else {
            return NextResponse.json(
              { error: `Row ${rowNumber}: ${error}` },
              { status: 400 }
            )
          }
        }

        // AI fuzzy role matching
        const normalizedRole = await matchRoleWithAI(mapped.role)

        // Normalize contract type
        const normalizedContractType = normalizeContractType(
          mapped.contractType
        )

        // Encrypt personnummer
        const cleanedPersonnummer = mapped.personnummer.replace(/\D/g, '')
        const encryptedPersonnummer = await encrypt(cleanedPersonnummer)

        // Create employee
        await prisma.employee.create({
          data: {
            workspaceId,
            name: mapped.name.trim(),
            personnummer: encryptedPersonnummer,
            email: mapped.email?.trim() || null,
            phone: mapped.phone?.trim() || null,
            employmentDate,
            contractType: normalizedContractType,
            role: normalizedRole,
            department: mapped.department?.trim() || null,
          },
        })

        // Log activity
        await prisma.employeeActivity.create({
          data: {
            employeeId: (await prisma.employee.findFirst({
              where: { workspaceId, personnummer: encryptedPersonnummer },
            }))!.id,
            userId,
            action: 'created',
            changes: { source: { old: null, new: 'csv_import' } },
          },
        })

        results.imported++
      } catch (error: any) {
        console.error(`Error importing row ${rowNumber}:`, error)
        if (skipInvalid) {
          results.skipped++
          results.errors.push({ row: rowNumber, errors: [error.message] })
        } else {
          return NextResponse.json(
            { error: `Row ${rowNumber}: ${error.message}` },
            { status: 500 }
          )
        }
      }
    }

    return NextResponse.json({ results })
  })
}

function parseDate(dateStr: string, format: string): Date | null {
  try {
    const cleaned = dateStr.trim()
    let year: number, month: number, day: number

    if (format === 'YYYY-MM-DD') {
      const parts = cleaned.split('-')
      year = parseInt(parts[0])
      month = parseInt(parts[1]) - 1
      day = parseInt(parts[2])
    } else if (format === 'DD/MM/YYYY') {
      const parts = cleaned.split('/')
      day = parseInt(parts[0])
      month = parseInt(parts[1]) - 1
      year = parseInt(parts[2])
    } else if (format === 'MM/DD/YYYY') {
      const parts = cleaned.split('/')
      month = parseInt(parts[0]) - 1
      day = parseInt(parts[1])
      year = parseInt(parts[2])
    } else if (format === 'DD-MM-YYYY') {
      const parts = cleaned.split('-')
      day = parseInt(parts[0])
      month = parseInt(parts[1]) - 1
      year = parseInt(parts[2])
    } else {
      return null
    }

    const date = new Date(year, month, day)
    if (isNaN(date.getTime())) {
      return null
    }
    return date
  } catch {
    return null
  }
}

async function matchRoleWithAI(roleInput: string): Promise<string> {
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [
        {
          role: 'system',
          content: `You are a role normalizer for HR systems. Given a job title or role, normalize it to one of these categories:
- manager
- employee
- intern
- consultant
- construction_worker
- office_worker
- warehouse_worker
- driver
- technician
- supervisor

If the input doesn't match any category clearly, return "employee" as the default.
Only respond with the normalized role, nothing else.`,
        },
        {
          role: 'user',
          content: `Normalize this role: "${roleInput}"`,
        },
      ],
      temperature: 0.3,
      max_tokens: 20,
    })

    const normalized =
      response.choices[0].message.content?.trim().toLowerCase() || 'employee'
    return normalized
  } catch (error) {
    console.error('AI role matching failed:', error)
    // Fallback to basic matching
    const lower = roleInput.toLowerCase()
    if (lower.includes('manager') || lower.includes('chef')) return 'manager'
    if (lower.includes('intern') || lower.includes('praktikant'))
      return 'intern'
    if (lower.includes('consultant') || lower.includes('konsult'))
      return 'consultant'
    if (lower.includes('build') || lower.includes('bygg'))
      return 'construction_worker'
    return 'employee'
  }
}

function normalizeContractType(input: string): string {
  const lower = input.toLowerCase()
  if (lower.includes('permanent') || lower.includes('tillsvidare'))
    return 'permanent'
  if (lower.includes('fixed') || lower.includes('visstid')) return 'fixed_term'
  if (lower.includes('consultant') || lower.includes('konsult'))
    return 'consultant'
  return 'permanent' // default
}
```

**Import Summary Component:**

```typescript
// components/hr/import-summary.tsx
'use client'

interface ImportSummaryProps {
  result: {
    imported: number
    skipped: number
    errors: Array<{ row: number; errors: string[] }>
  }
  onClose: () => void
}

export function ImportSummary({ result, onClose }: ImportSummaryProps) {
  function downloadErrorLog() {
    const csv = [
      'Row Number,Errors',
      ...result.errors.map((e) => `${e.row},"${e.errors.join('; ')}"`)
    ].join('\n')

    const blob = new Blob([csv], { type: 'text/csv' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `import-errors-${Date.now()}.csv`
    link.click()
    URL.revokeObjectURL(url)
  }

  return (
    <div className="text-center py-8">
      {result.imported > 0 ? (
        <div className="mb-6">
          <svg className="mx-auto h-16 w-16 text-green-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h3 className="text-2xl font-bold text-gray-900 mb-2">Import Complete!</h3>
        </div>
      ) : (
        <div className="mb-6">
          <svg className="mx-auto h-16 w-16 text-red-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
          <h3 className="text-2xl font-bold text-gray-900 mb-2">Import Failed</h3>
        </div>
      )}

      <div className="grid grid-cols-2 gap-4 mb-8">
        <div className="p-4 bg-green-50 rounded-lg">
          <p className="text-sm text-green-600 font-medium">Imported</p>
          <p className="text-3xl font-bold text-green-900">{result.imported}</p>
        </div>
        <div className="p-4 bg-red-50 rounded-lg">
          <p className="text-sm text-red-600 font-medium">Skipped</p>
          <p className="text-3xl font-bold text-red-900">{result.skipped}</p>
        </div>
      </div>

      {result.errors.length > 0 && (
        <div className="mb-6">
          <button
            onClick={downloadErrorLog}
            className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-sm"
          >
            Download Error Log
          </button>
        </div>
      )}

      <button
        onClick={onClose}
        className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
      >
        Done
      </button>
    </div>
  )
}
```

**Reference:** PRD Epic 7 Story 7.3, OpenAI API documentation, CSV parsing standards

## Testing

**Unit Tests:**

- CSV parsing handles quoted fields correctly
- Auto-detection maps common column names
- Date parsing supports all formats
- Validation catches missing required fields
- AI role matching normalizes variations correctly

**Integration Tests:**

- Import CSV with 50 employees, verify all imported
- Import with invalid rows, verify skipped correctly
- Import with mixed valid/invalid rows, verify summary accurate
- AI role matching: "CEO" → "manager", "Builder" → "construction_worker"
- Download error log, verify CSV format correct

**Manual Testing:**

- Upload CSV file, verify preview shows first 10 rows
- Map columns manually, verify fields update correctly
- Select different date formats, verify parsing works
- Import with all valid data, verify success message
- Import with some invalid rows, verify skip option works
- Download error log, verify contains all skipped rows
- Verify all imported employees appear in Employee List
- Test as non-HR Manager role, verify access blocked

**Edge Cases:**

- Empty CSV file (show error)
- CSV with only headers (show error)
- CSV with missing headers (manual mapping required)
- Personnummer with hyphens or spaces (strip before validation)
- Date in unexpected format (show error with row number)
- Duplicate personnummer (show error, skip row)
- Very large CSV (5000 rows) - test performance and timeout handling

**Security Testing:**

- Validate file type (reject .exe, .js, etc.)
- Validate file size (max 10MB)
- Personnummer encrypted before storing
- Cannot import to other workspace
- CSV injection prevention (escape formulas in error log)

**Performance Testing:**

- Import 100 employees completes <30 seconds
- Import 1000 employees completes <5 minutes
- AI role matching cached for duplicate roles (avoid redundant API calls)

**Test File:** `__tests__/features/hr/employee-import.test.tsx`

## User vs Developer Responsibilities

**User Responsibility:**

- Prepare CSV file with correct columns and data
- Map columns correctly if auto-detection fails
- Select correct date format
- Review preview and validation errors before importing
- Download and review error log for skipped rows

**Developer Responsibility:**

- Parse CSV files correctly (handle quoted fields, edge cases)
- Auto-detect common column names to minimize manual mapping
- Validate all data before import (required fields, formats)
- Use AI to fuzzy-match role variations intelligently
- Encrypt personnummer before storing
- Provide clear error messages with row numbers
- Generate downloadable error log for troubleshooting
- Handle large files efficiently (chunking, streaming)
- Prevent CSV injection attacks in error log

## Change Log

| Date       | Version | Description            | Author     |
| ---------- | ------- | ---------------------- | ---------- |
| 2025-11-12 | 1.0     | Initial story creation | Sarah (PO) |

## Dev Agent Record

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
