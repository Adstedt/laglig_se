# Story 2.20: Search Performance - PostgreSQL Optimization + Elasticsearch

## Status

Draft

## Story

**As a** visitor searching for legal content on Laglig.se,
**I want** search results to return in under 200ms regardless of query complexity,
**so that** I can find relevant laws, court cases, and EU legislation instantly.

## Background

### Current State (Problem)

The current search infrastructure uses PostgreSQL full-text search with `tsvector`:

| Metric | Current Performance |
|--------|---------------------|
| Simple browse query | 1,500-5,000ms |
| Full-text search | 2,000-8,000ms |
| Filtered + sorted | 3,000-10,000ms |
| COUNT(*) on 170K docs | 500-2,000ms |

**Root Causes:**
1. Missing composite indexes for common filter combinations
2. COUNT(*) requires full table scan on 170K+ rows
3. No pre-computed counts for filter combinations
4. `tsvector` full-text search lacks fuzzy matching
5. No trigram index for typo-tolerant search

### Two-Phase Approach

This story takes a **"try free first"** approach:

**Phase A: PostgreSQL Optimization (Free)**
- Add composite indexes
- Create materialized views for counts
- Add pg_trgm for fuzzy search
- Optimize query patterns

**Phase B: Elasticsearch (If Needed)**
- Only proceed if Phase A doesn't meet performance targets
- Provides sub-100ms queries, faceting, and advanced search

### Target Performance

| Query Type | Current | Phase A Target | Phase B Target |
|------------|---------|----------------|----------------|
| Simple browse | 1,500ms | <300ms | <100ms |
| Full-text search | 5,000ms | <500ms | <150ms |
| Filtered + facets | 8,000ms | <600ms | <200ms |
| Autocomplete | 500ms | <100ms | <50ms |
| COUNT queries | 2,000ms | <50ms | <10ms |

---

## Phase A: PostgreSQL Optimization

### Acceptance Criteria (Phase A)

#### A1: Composite Indexes

1. [ ] Add composite index on `(content_type, status, effective_date DESC)`
2. [ ] Add composite index on `(effective_date DESC NULLS LAST)`
3. [ ] Add partial index for active documents only
4. [ ] Verify indexes are used via `EXPLAIN ANALYZE`

#### A2: Materialized Views for Counts

5. [ ] Create materialized view `browse_counts` with pre-computed counts
6. [ ] Create refresh function for materialized view
7. [ ] Add cron job to refresh every hour
8. [ ] Update browse queries to use materialized view for counts

#### A3: pg_trgm Fuzzy Search

9. [ ] Enable pg_trgm extension
10. [ ] Add GIN trigram index on title
11. [ ] Add GIN trigram index on document_number
12. [ ] Implement fuzzy autocomplete using trigram similarity

#### A4: Query Optimization

13. [ ] Optimize `browseWithoutQuery` to use new indexes
14. [ ] Replace COUNT(*) with materialized view lookup
15. [ ] Add query hints for index usage
16. [ ] Benchmark all query patterns

#### A5: Performance Validation (Phase A)

17. [ ] Browse queries under 300ms
18. [ ] Search queries under 500ms
19. [ ] COUNT queries under 50ms
20. [ ] Document benchmark results

### Tasks (Phase A)

### Task A1: Add Composite Indexes (2 hours)

- [ ] Create migration `add_browse_performance_indexes`
- [ ] Add indexes:
  ```sql
  -- Primary browse index
  CREATE INDEX CONCURRENTLY idx_legal_docs_browse_composite
  ON legal_documents (content_type, status, effective_date DESC NULLS LAST);

  -- Date sorting index (most common sort)
  CREATE INDEX CONCURRENTLY idx_legal_docs_effective_date_desc
  ON legal_documents (effective_date DESC NULLS LAST);

  -- Partial index for active documents (80% of queries)
  CREATE INDEX CONCURRENTLY idx_legal_docs_active_by_date
  ON legal_documents (effective_date DESC NULLS LAST)
  WHERE status = 'ACTIVE';

  -- Content type + date for filtered browse
  CREATE INDEX CONCURRENTLY idx_legal_docs_type_date
  ON legal_documents (content_type, effective_date DESC NULLS LAST);
  ```
- [ ] Run migration on production
- [ ] Verify with `EXPLAIN ANALYZE`

### Task A2: Materialized View for Counts (3 hours)

- [ ] Create migration `add_browse_count_materialized_view`
- [ ] Create materialized view:
  ```sql
  -- Pre-computed counts by filter combination
  CREATE MATERIALIZED VIEW browse_counts AS
  SELECT
    content_type,
    status,
    COUNT(*) as doc_count,
    MIN(effective_date) as min_date,
    MAX(effective_date) as max_date
  FROM legal_documents
  GROUP BY content_type, status
  WITH DATA;

  -- Index for fast lookups
  CREATE UNIQUE INDEX idx_browse_counts_pk
  ON browse_counts (content_type, status);

  -- Total count view
  CREATE MATERIALIZED VIEW browse_total_count AS
  SELECT COUNT(*) as total_count FROM legal_documents
  WITH DATA;
  ```
- [ ] Create refresh function:
  ```sql
  CREATE OR REPLACE FUNCTION refresh_browse_counts()
  RETURNS void AS $$
  BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY browse_counts;
    REFRESH MATERIALIZED VIEW browse_total_count;
  END;
  $$ LANGUAGE plpgsql;
  ```
- [ ] Add to cron schedule (hourly refresh)
- [ ] Update `browse.ts` to use materialized view for counts

### Task A3: pg_trgm Fuzzy Search (2 hours)

- [ ] Create migration `add_trigram_indexes`
- [ ] Enable extension and add indexes:
  ```sql
  -- Enable trigram extension
  CREATE EXTENSION IF NOT EXISTS pg_trgm;

  -- Trigram index for fuzzy title search
  CREATE INDEX CONCURRENTLY idx_legal_docs_title_trgm
  ON legal_documents USING GIN (title gin_trgm_ops);

  -- Trigram index for document number search
  CREATE INDEX CONCURRENTLY idx_legal_docs_docnum_trgm
  ON legal_documents USING GIN (document_number gin_trgm_ops);
  ```
- [ ] Update autocomplete to use trigram similarity:
  ```sql
  SELECT title, slug, content_type, document_number,
         similarity(title, $1) as sim
  FROM legal_documents
  WHERE title % $1 OR document_number % $1
  ORDER BY sim DESC
  LIMIT 6;
  ```
- [ ] Test fuzzy matching (e.g., "arbetsmiljo" finds "arbetsmiljÃ¶")

### Task A4: Update Browse Queries (3 hours)

- [ ] Update `app/actions/browse.ts`:
  - [ ] Use materialized view for total count
  - [ ] Add query hints for index usage
  - [ ] Optimize filter combinations
- [ ] Create optimized browse function:
  ```typescript
  async function getOptimizedCount(where: WhereClause): Promise<number> {
    // For unfiltered queries, use materialized view
    if (Object.keys(where).length === 0) {
      const result = await prisma.$queryRaw`
        SELECT total_count FROM browse_total_count
      `
      return result[0].total_count
    }

    // For simple filters, use materialized view aggregation
    if (isSimpleFilter(where)) {
      const result = await prisma.$queryRaw`
        SELECT SUM(doc_count) as total
        FROM browse_counts
        WHERE content_type = ANY(${where.content_type?.in || []})
          AND status = ANY(${where.status?.in || []})
      `
      return result[0].total
    }

    // Fall back to COUNT for complex filters
    return prisma.legalDocument.count({ where })
  }
  ```
- [ ] Add `SET enable_seqscan = off` hint for indexed queries
- [ ] Test all filter combinations

### Task A5: Performance Benchmarking (2 hours)

- [ ] Create benchmark script `scripts/benchmark-browse.ts`
- [ ] Test scenarios:
  - [ ] Default browse (no filters)
  - [ ] Single filter (content_type)
  - [ ] Multiple filters (content_type + status)
  - [ ] Date range filter
  - [ ] Full-text search
  - [ ] Autocomplete
- [ ] Document results in story completion notes
- [ ] Compare against Phase A targets

---

## Phase B: Elasticsearch (Conditional)

**Only proceed with Phase B if Phase A does not meet performance targets.**

### Decision Gate

After Phase A completion, evaluate:
- [ ] Are browse queries under 300ms?
- [ ] Are search queries under 500ms?
- [ ] Are COUNT queries under 50ms?

**If YES to all:** Close story as complete. PostgreSQL is sufficient.
**If NO:** Continue with Phase B.

### Acceptance Criteria (Phase B)

#### B1: Infrastructure Setup

21. [ ] Select provider (Bonsai recommended for cost)
22. [ ] Create index schema for legal documents
23. [ ] Configure Swedish language analyzer
24. [ ] Set up secure connection from Vercel

#### B2: Data Sync

25. [ ] Create initial bulk indexing script
26. [ ] Index all 170K+ documents
27. [ ] Set up incremental sync from database

#### B3: Search API

28. [ ] Create `lib/search/elasticsearch.ts` client
29. [ ] Implement `searchDocuments()` function
30. [ ] Implement `browseDocuments()` function
31. [ ] Implement `getAutocomplete()` function

#### B4: Integration

32. [ ] Replace PostgreSQL queries with Elasticsearch
33. [ ] Keep PostgreSQL as fallback
34. [ ] Add search analytics tracking

### Tasks (Phase B)

### Task B1: Provider Selection & Setup (2 hours)

- [ ] Evaluate providers:
  | Provider | Free Tier | Pricing | Notes |
  |----------|-----------|---------|-------|
  | **Bonsai** | 125MB, 10K docs | $10/mo for 1GB | Recommended |
  | **Typesense Cloud** | None | $29/mo | Simpler API |
  | **Elastic Cloud** | 14-day trial | $95/mo | Full features |
- [ ] Create account and provision instance
- [ ] Add env vars to Vercel:
  - `ELASTICSEARCH_URL`
  - `ELASTICSEARCH_API_KEY`
- [ ] Test connection from local dev

### Task B2: Index Schema Design (3 hours)

- [ ] Create index mapping:
  ```json
  {
    "settings": {
      "analysis": {
        "analyzer": {
          "swedish_custom": {
            "type": "custom",
            "tokenizer": "standard",
            "filter": ["lowercase", "swedish_stemmer", "swedish_stop"]
          }
        },
        "filter": {
          "swedish_stemmer": { "type": "stemmer", "language": "swedish" },
          "swedish_stop": { "type": "stop", "stopwords": "_swedish_" }
        }
      }
    },
    "mappings": {
      "properties": {
        "id": { "type": "keyword" },
        "title": {
          "type": "text",
          "analyzer": "swedish_custom",
          "fields": {
            "keyword": { "type": "keyword" },
            "suggest": { "type": "completion" }
          }
        },
        "document_number": { "type": "keyword" },
        "content_type": { "type": "keyword" },
        "status": { "type": "keyword" },
        "summary": { "type": "text", "analyzer": "swedish_custom" },
        "full_text": { "type": "text", "analyzer": "swedish_custom" },
        "effective_date": { "type": "date" },
        "slug": { "type": "keyword" },
        "subjects": {
          "type": "nested",
          "properties": {
            "code": { "type": "keyword" },
            "name": { "type": "text" }
          }
        }
      }
    }
  }
  ```
- [ ] Configure Swedish analyzer with legal synonyms
- [ ] Create index

### Task B3: Bulk Indexing Script (4 hours)

- [ ] Create `scripts/index-elasticsearch.ts`
- [ ] Implement batch fetching from PostgreSQL
- [ ] Implement bulk indexing with progress tracking
- [ ] Handle errors and retries
- [ ] Verify document count matches

### Task B4: Search Client Implementation (4 hours)

- [ ] Create `lib/search/elasticsearch.ts`:
  ```typescript
  export async function searchDocuments(params: SearchParams): Promise<SearchResult>
  export async function browseDocuments(params: BrowseParams): Promise<BrowseResult>
  export async function getAutocomplete(query: string): Promise<Suggestion[]>
  ```
- [ ] Implement query building with filters
- [ ] Add highlighting for search results
- [ ] Implement faceted aggregations

### Task B5: Browse Integration (3 hours)

- [ ] Update `app/actions/browse.ts` to use Elasticsearch
- [ ] Keep PostgreSQL as fallback:
  ```typescript
  async function browseDocumentsAction(input: BrowseInput) {
    try {
      if (isElasticsearchConfigured) {
        return await elasticsearchBrowse(input)
      }
    } catch (error) {
      console.error('ES error, falling back to PostgreSQL:', error)
    }
    return await postgresqlBrowse(input)
  }
  ```
- [ ] Test all filter combinations

### Task B6: Incremental Sync (3 hours)

- [ ] Create `app/api/cron/sync-elasticsearch/route.ts`
- [ ] Query documents updated since last sync
- [ ] Bulk update/insert changed documents
- [ ] Add to Vercel cron schedule (every 15 min)

### Task B7: Performance Validation (2 hours)

- [ ] Benchmark all query types
- [ ] Compare with Phase A results
- [ ] Document final performance numbers

---

## Dev Notes

### PostgreSQL Query Optimization Tips

```sql
-- Check if indexes are being used
EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT)
SELECT * FROM legal_documents
WHERE content_type = 'SFS_LAW'
ORDER BY effective_date DESC
LIMIT 25;

-- Force index usage if needed
SET enable_seqscan = off;

-- Check index sizes
SELECT
  indexname,
  pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_indexes
WHERE tablename = 'legal_documents';
```

### Materialized View Refresh Pattern

```typescript
// app/api/cron/refresh-counts/route.ts
import { prisma } from '@/lib/prisma'

export async function GET() {
  await prisma.$executeRaw`SELECT refresh_browse_counts()`
  return Response.json({ success: true })
}
```

### Trigram Similarity Query

```typescript
// Fuzzy autocomplete using pg_trgm
const suggestions = await prisma.$queryRaw`
  SELECT
    title,
    slug,
    content_type,
    document_number,
    similarity(title, ${query}) as sim
  FROM legal_documents
  WHERE title % ${query}
     OR document_number % ${query}
  ORDER BY sim DESC
  LIMIT 6
`
```

### Elasticsearch Client (Phase B)

```typescript
// lib/search/elasticsearch.ts
import { Client } from '@elastic/elasticsearch'

const client = process.env.ELASTICSEARCH_URL
  ? new Client({
      node: process.env.ELASTICSEARCH_URL,
      auth: { apiKey: process.env.ELASTICSEARCH_API_KEY! }
    })
  : null

export const isElasticsearchConfigured = Boolean(client)

export async function searchDocuments(params: SearchParams) {
  if (!client) throw new Error('Elasticsearch not configured')

  const { query, contentTypes, status, page = 1, limit = 25 } = params

  const response = await client.search({
    index: 'legal_documents',
    body: {
      query: {
        bool: {
          must: query ? [{
            multi_match: {
              query,
              fields: ['title^3', 'summary^2', 'full_text'],
              fuzziness: 'AUTO'
            }
          }] : [{ match_all: {} }],
          filter: [
            ...(contentTypes?.length ? [{ terms: { content_type: contentTypes } }] : []),
            ...(status?.length ? [{ terms: { status } }] : [])
          ]
        }
      },
      sort: [{ effective_date: 'desc' }],
      from: (page - 1) * limit,
      size: limit,
      aggs: {
        by_type: { terms: { field: 'content_type' } },
        by_status: { terms: { field: 'status' } }
      }
    }
  })

  return {
    results: response.hits.hits.map(hit => ({ id: hit._id, ...hit._source })),
    total: response.hits.total.value,
    facets: response.aggregations
  }
}
```

---

## Dependencies

- **Depends on:** Story 2.19 (Caching) - caching should be implemented first
- **Phase A:** No external dependencies (PostgreSQL only)
- **Phase B:** Elasticsearch/Typesense provider account

## Estimated Effort

### Phase A (PostgreSQL Optimization)

| Task | Effort |
|------|--------|
| Task A1: Composite Indexes | 2 hours |
| Task A2: Materialized Views | 3 hours |
| Task A3: pg_trgm Fuzzy Search | 2 hours |
| Task A4: Query Optimization | 3 hours |
| Task A5: Benchmarking | 2 hours |

**Phase A Total: ~12 hours (2 days)**

### Phase B (Elasticsearch - Conditional)

| Task | Effort |
|------|--------|
| Task B1: Provider Setup | 2 hours |
| Task B2: Index Schema | 3 hours |
| Task B3: Bulk Indexing | 4 hours |
| Task B4: Search Client | 4 hours |
| Task B5: Browse Integration | 3 hours |
| Task B6: Incremental Sync | 3 hours |
| Task B7: Performance Validation | 2 hours |

**Phase B Total: ~21 hours (3.5 days)**

**Maximum Total: ~33 hours (5.5 days)**

---

## Success Metrics

### Phase A Targets

| Metric | Before | Phase A Target |
|--------|--------|----------------|
| Browse (no filter) | 1,500ms | <300ms |
| Browse (filtered) | 3,000ms | <400ms |
| Full-text search | 5,000ms | <500ms |
| COUNT query | 2,000ms | <50ms |
| Autocomplete | 500ms | <100ms |

### Phase B Targets (if needed)

| Metric | Phase A | Phase B Target |
|--------|---------|----------------|
| Browse | <300ms | <100ms |
| Full-text search | <500ms | <150ms |
| Faceted search | N/A | <200ms |
| Autocomplete | <100ms | <50ms |

---

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Indexes don't help enough | Low | Medium | Proceed to Phase B |
| Materialized view staleness | Medium | Low | Frequent refresh (hourly) |
| ES data sync lag | Medium | Medium | Real-time sync + fallback |
| ES downtime | Low | High | PostgreSQL fallback |
| Phase B cost | Medium | Low | Start with Bonsai $10/mo |

---

## Dev Agent Record

### Agent Model Used

(To be filled during implementation)

### File List

(To be filled during implementation)

### Completion Notes

(To be filled during implementation)

### Phase A Benchmark Results

(To be filled after Phase A completion)

| Query Type | Before | After | Target Met? |
|------------|--------|-------|-------------|
| Browse (no filter) | | | |
| Browse (filtered) | | | |
| Full-text search | | | |
| COUNT query | | | |
| Autocomplete | | | |

### Debug Log References

(To be filled during implementation)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-10 | 1.0 | Created - Elasticsearch search infrastructure | Claude |
| 2025-12-10 | 2.0 | Added Phase A: PostgreSQL optimization before Elasticsearch | Claude |
