# Story 5.1: Implement Workspace Data Model and Multi-Tenancy

## Status
Draft

## Story

**As a** developer,
**I want** to build workspace-based multi-tenancy architecture,
**so that** each company's data is isolated and team members share access.

## Acceptance Criteria

1. Prisma schema updated with `workspaces` table: id, name, owner_id, company_logo, created_at, subscription_tier, trial_ends_at, status (active/paused/deleted)
2. `workspace_members` table: id, workspace_id, user_id, role (owner/admin/hr_manager/member/auditor), invited_at, joined_at
3. Row-Level Security (RLS) policies ensure users only access their workspace data
4. All core tables (laws_in_workspace, employees, tasks, chat_messages) include workspace_id foreign key
5. Database queries scoped to workspace_id by default
6. Middleware checks user has access to requested workspace
7. Test: User A cannot access User B's workspace data
8. Test: Workspace deletion cascades to all related data (soft-delete)

## Tasks / Subtasks

- [ ] Update Prisma schema with workspaces and workspace_members tables
- [ ] Add workspace_id foreign key to all core tables
- [ ] Implement Row-Level Security policies in Supabase
- [ ] Create middleware to check workspace access
- [ ] Implement workspace context helper functions
- [ ] Add soft-delete cascade logic
- [ ] Test data isolation between workspaces
- [ ] Test workspace deletion cascades

## Dev Notes

**Prisma Schema Updates:**
```prisma
// schema.prisma

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  password      String
  emailVerified Boolean  @default(false)
  createdAt     DateTime @default(now())

  ownedWorkspaces    Workspace[]       @relation("WorkspaceOwner")
  workspaceMemberships WorkspaceMember[]
  verificationCodes  VerificationCode[]
  chatMessages       ChatMessage[]
  activityLogs       WorkspaceActivityLog[]

  @@map("users")
}

model Workspace {
  id                String   @id @default(uuid())
  name              String
  ownerId           String
  companyLogo       String?
  subscriptionTier  String   @default("trial") // trial, solo, team, enterprise
  trialEndsAt       DateTime?
  status            String   @default("active") // active, paused, deleted
  pausedAt          DateTime?
  deletedAt         DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  owner            User              @relation("WorkspaceOwner", fields: [ownerId], references: [id])
  members          WorkspaceMember[]
  companyProfile   CompanyProfile?
  laws             WorkspaceLaw[]
  employees        Employee[]
  tasks            Task[]
  chatMessages     ChatMessage[]
  activityLogs     WorkspaceActivityLog[]
  costs            WorkspaceCost[]
  usage            WorkspaceUsage?

  @@index([ownerId])
  @@index([status])
  @@map("workspaces")
}

model WorkspaceMember {
  id          String   @id @default(uuid())
  workspaceId String
  userId      String
  role        String   // owner, admin, hr_manager, member, auditor
  invitedAt   DateTime @default(now())
  joinedAt    DateTime?

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, userId])
  @@index([userId])
  @@map("workspace_members")
}

model CompanyProfile {
  id               String @id @default(uuid())
  workspaceId      String @unique
  companyName      String
  sniCode          String
  legalForm        String
  employeeCount    Int
  address          String?
  contextualAnswers Json? // From onboarding questions

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@map("company_profiles")
}

model WorkspaceLaw {
  id          String   @id @default(uuid())
  workspaceId String
  lawId       String
  commentary  String?  // AI-generated reason why this law applies
  category    String
  phase       Int      // 1 or 2 (from onboarding)
  status      String   @default("not_started") // not_started, in_progress, blocked, review, compliant
  priority    String   @default("medium") // low, medium, high
  notes       String?
  addedAt     DateTime @default(now())

  workspace Workspace     @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  law       LegalDocument @relation(fields: [lawId], references: [id])

  @@index([workspaceId, status])
  @@index([workspaceId, phase])
  @@map("workspace_laws")
}

model Employee {
  id          String   @id @default(uuid())
  workspaceId String
  firstName   String
  lastName    String
  email       String?
  position    String?
  department  String?
  hiredDate   DateTime?
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@map("employees")
}

model Task {
  id          String   @id @default(uuid())
  workspaceId String
  lawId       String?
  title       String
  description String?
  assignedTo  String?  // User ID
  dueDate     DateTime?
  completed   Boolean  @default(false)
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId])
  @@map("tasks")
}

model ChatMessage {
  id          String   @id @default(uuid())
  workspaceId String
  userId      String
  role        String   // user, assistant
  content     String   @db.Text
  metadata    Json?    // citations, context, etc.
  createdAt   DateTime @default(now())

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)
  user      User      @relation(fields: [userId], references: [id])

  @@index([workspaceId, createdAt])
  @@map("chat_messages")
}
```

**Row-Level Security Policies (Supabase):**
```sql
-- Enable RLS on all tables
ALTER TABLE workspaces ENABLE ROW LEVEL SECURITY;
ALTER TABLE workspace_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE workspace_laws ENABLE ROW LEVEL SECURITY;
ALTER TABLE employees ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE chat_messages ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access workspaces they are members of
CREATE POLICY workspace_member_access ON workspaces
  FOR ALL
  USING (
    id IN (
      SELECT workspace_id
      FROM workspace_members
      WHERE user_id = auth.uid()
    )
  );

-- Policy: Users can only access workspace_members for their workspaces
CREATE POLICY workspace_members_access ON workspace_members
  FOR ALL
  USING (
    workspace_id IN (
      SELECT workspace_id
      FROM workspace_members
      WHERE user_id = auth.uid()
    )
  );

-- Policy: Users can only access laws in their workspaces
CREATE POLICY workspace_laws_access ON workspace_laws
  FOR ALL
  USING (
    workspace_id IN (
      SELECT workspace_id
      FROM workspace_members
      WHERE user_id = auth.uid()
    )
  );

-- Similar policies for employees, tasks, chat_messages
```

**Workspace Context Middleware:**
```typescript
// middleware/workspace-context.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function workspaceMiddleware(request: NextRequest) {
  // Get user session
  const session = await getSession(request)

  if (!session) {
    return NextResponse.redirect('/login')
  }

  // Get workspace ID from cookie or path
  let workspaceId = request.cookies.get('active_workspace_id')?.value

  // If no workspace in cookie, get user's first workspace
  if (!workspaceId) {
    const workspace = await prisma.workspace.findFirst({
      where: {
        members: {
          some: {
            userId: session.userId
          }
        },
        status: 'active'
      }
    })

    if (!workspace) {
      return NextResponse.redirect('/onboarding')
    }

    workspaceId = workspace.id
  }

  // Verify user has access to this workspace
  const member = await prisma.workspaceMember.findUnique({
    where: {
      workspaceId_userId: {
        workspaceId,
        userId: session.userId
      }
    }
  })

  if (!member) {
    // User doesn't have access to this workspace
    return NextResponse.json(
      { error: 'Access denied to this workspace' },
      { status: 403 }
    )
  }

  // Add workspace context to request
  const response = NextResponse.next()
  response.headers.set('X-Workspace-Id', workspaceId)
  response.headers.set('X-Workspace-Role', member.role)

  return response
}
```

**Workspace Context Helper:**
```typescript
// lib/workspace-context.ts
import { getServerSession } from 'next-auth'
import { authOptions } from '@/app/api/auth/[...nextauth]/route'

export async function getWorkspaceContext() {
  const session = await getServerSession(authOptions)

  if (!session?.user?.id) {
    throw new Error('Unauthorized')
  }

  // Get active workspace from cookie or session
  const workspaceId = // ... get from cookie or session

  // Get workspace with user's role
  const member = await prisma.workspaceMember.findUnique({
    where: {
      workspaceId_userId: {
        workspaceId,
        userId: session.user.id
      }
    },
    include: {
      workspace: true
    }
  })

  if (!member) {
    throw new Error('Access denied to workspace')
  }

  return {
    userId: session.user.id,
    workspaceId: member.workspaceId,
    workspace: member.workspace,
    role: member.role
  }
}

// Helper to scope queries to workspace
export async function withWorkspace<T>(
  callback: (context: WorkspaceContext) => Promise<T>
): Promise<T> {
  const context = await getWorkspaceContext()
  return callback(context)
}
```

**Usage in API Routes:**
```typescript
// app/api/laws/route.ts
export async function GET(request: Request) {
  return withWorkspace(async ({ workspaceId, role }) => {
    const laws = await prisma.workspaceLaw.findMany({
      where: { workspaceId },
      include: { law: true }
    })

    return NextResponse.json(laws)
  })
}
```

**Soft-Delete Cascade:**
```typescript
// lib/workspace/delete-workspace.ts
export async function softDeleteWorkspace(workspaceId: string) {
  await prisma.$transaction(async (tx) => {
    // Soft-delete workspace
    await tx.workspace.update({
      where: { id: workspaceId },
      data: {
        status: 'deleted',
        deletedAt: new Date()
      }
    })

    // Note: Related data is automatically hidden by RLS policies
    // and will be hard-deleted after 30 days by cron job
  })
}

// Cron job to hard-delete after 30 days
export async function hardDeleteExpiredWorkspaces() {
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)

  const expiredWorkspaces = await prisma.workspace.findMany({
    where: {
      status: 'deleted',
      deletedAt: {
        lte: thirtyDaysAgo
      }
    }
  })

  for (const workspace of expiredWorkspaces) {
    await prisma.$transaction(async (tx) => {
      // Hard delete all related data (Prisma cascade handles this)
      await tx.workspace.delete({
        where: { id: workspace.id }
      })
    })

    console.log(`Hard-deleted workspace: ${workspace.id}`)
  }
}
```

**Reference:** PRD Epic 5 Story 5.1, Architecture Section 9 (Database Schema), Architecture Section 12 (Multi-Tenancy)

## Testing

**Unit Tests:**
- Workspace context helper returns correct workspace
- Middleware blocks access to unauthorized workspace
- Soft-delete sets status to 'deleted' and timestamp
- Hard-delete removes all related data

**Integration Tests:**
- Create workspace, verify owner can access
- Add member to workspace, verify member can access
- User A cannot access User B's workspace data
- Workspace deletion cascades to laws, employees, tasks, messages
- RLS policies enforce data isolation

**Manual Testing:**
- Create 2 workspaces, verify data isolation
- Add member to workspace, verify they can access
- Remove member, verify they lose access
- Soft-delete workspace, verify data hidden
- Hard-delete workspace, verify data removed

**Security Testing:**
- Attempt to access another workspace's data (should fail)
- Attempt to bypass RLS with raw SQL (should fail)
- Verify workspace_id required in all queries

**Test File:** `__tests__/features/workspace/multi-tenancy.test.ts`

## User vs Developer Responsibilities

**User Responsibility:**
- Create workspace during onboarding
- Invite team members to workspace
- Manage workspace settings

**Developer Responsibility:**
- Implement workspace-based multi-tenancy
- Enforce RLS policies in database
- Scope all queries to workspace_id
- Implement middleware to check workspace access
- Prevent data leakage between workspaces
- Handle workspace deletion (soft and hard delete)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-12 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
