# Story 14.1: Standardized Document JSON Schema & Derivation

## Status

Draft

## Story

**As a** platform building a RAG pipeline,
**I want** all legal documents to have a standardized hierarchical JSON representation,
**so that** downstream chunking and retrieval work consistently across all content types.

## Context & Dependencies

**Why this story exists:**

The existing `htmlToJson` transform in `lib/transforms/html-to-json.ts` was built for Story 2.29 (amendment documents) and produces a flat section-based structure (`sections: Section[]` with nested `children`). This format is content-type-aware but not standardized across SFS laws, amendments, and agency regulations. Only 47 of 10,803 SFS laws have `json_content` today. The RAG pipeline (Epic 14) needs a canonical hierarchical schema — `chapters > sections > paragraphs` — so that the chunking pipeline (Story 14.2) can reliably break any legal document into paragraph-level chunks with contextual headers.

**Builds on:**

- `lib/transforms/html-to-json.ts` — existing parser producing `LegalDocumentJson` with `sections: Section[]` structure [Source: lib/transforms/html-to-json.ts:26]
- `lib/transforms/html-to-markdown.ts` — existing HTML-to-Markdown converter [Source: lib/transforms/html-to-markdown.ts:1]
- `LegalDocument` model — `html_content` (SSOT), `json_content` (Json?), `markdown_content` (Text?) [Source: prisma/schema.prisma:292-294]
- `ContentType` enum — `SFS_LAW`, `SFS_AMENDMENT`, `AGENCY_REGULATION` [Source: prisma/schema.prisma:358-370]
- HTML is assumed to already exist for all documents (HTML backfill is handled separately)

**Depends on:** Nothing. This is the foundation story for Epic 14 Phase 1.

**Depended on by:**

- Story 14.2 (ContentChunk Model & Chunking Pipeline) — consumes `json_content` in canonical schema to produce chunks
- Story 14.3 (Embedding Generation Pipeline) — operates on chunks derived from this schema
- All downstream RAG stories that query structured content

## Acceptance Criteria

### Canonical JSON Schema

1. Canonical JSON schema defined as TypeScript interfaces in `lib/transforms/document-json-schema.ts` — hierarchical structure: `{ chapters: [{ number, title, sections: [{ number, paragraphs: [{ number, text, role }] }] }] }`
2. Schema supports all three content types: `SFS_LAW`, `SFS_AMENDMENT`, `AGENCY_REGULATION`
3. Documents without chapters (flat structure) use a single implicit chapter with `number: null` and `title: null`
4. Each paragraph has a `role` field using the `ContentRole` enum: `PARAGRAPH`, `ALLMANT_RAD`, `TABLE`, `HEADING`, `TRANSITION_PROVISION`, `FOOTNOTE`

### Content Type Parsers

5. Parser for Riksdag HTML (SFS laws) extracts hierarchy from `name="K1P1"` anchors and `class="paragraf"` markers — produces canonical schema output
6. Parser for amendment HTML extracts paragraph-level structure from existing semantic IDs (e.g., `id="SFS2025-732_K6_P17_S1"`) — breaks chapter-level content blobs into paragraph-level entries
7. Parser for agency regulation HTML extracts from `section.kapitel`, `h3.paragraph`, `p.text` classes — produces canonical schema output

### Integration & Refactoring

8. Existing `htmlToJson` in `lib/transforms/html-to-json.ts` refactored or replaced to produce canonical schema — dispatcher routes to correct parser based on `content_type`
9. Markdown derivation produces clean output for all content types — update `htmlToMarkdown` in `lib/transforms/html-to-markdown.ts` if needed

### Batch Processing

10. Batch script `scripts/derive-json-md-content.ts` processes all documents with HTML, updating `json_content` and `markdown_content`
11. Script has progress logging (`"Processed 500/10,803 SFS_LAW documents (4.6%)"`), resume-on-failure (cursor tracking), and `--dry-run` mode

### Validation & Testing

12. Schema validation function exists in `lib/transforms/validate-document-json.ts` to verify JSON matches canonical schema (using Zod)
13. At least 20 unit tests covering all three content type parsers with edge cases

## Tasks / Subtasks

- [ ] **Task 1: Define canonical JSON schema** (AC: 1-4)
  - [ ] Create `lib/transforms/document-json-schema.ts` with TypeScript interfaces
  - [ ] Define `CanonicalDocumentJson` top-level interface with `documentType`, `title`, `documentNumber`, `chapters` array
  - [ ] Define `CanonicalChapter` interface with `number` (string | null), `title` (string | null), `sections` array
  - [ ] Define `CanonicalSection` interface with `number` (string, e.g., "15", "2a"), `heading` (string | null), `paragraphs` array
  - [ ] Define `CanonicalParagraph` interface with `number` (number | null for sentences), `text` (string), `role` (ContentRole enum), `htmlContent` (string, optional — raw HTML for rendering)
  - [ ] Define `ContentRole` enum: `PARAGRAPH`, `ALLMANT_RAD`, `TABLE`, `HEADING`, `TRANSITION_PROVISION`, `FOOTNOTE`
  - [ ] Document all interfaces with JSDoc comments explaining purpose, invariants, and examples
  - [ ] Ensure implicit chapter (number: null, title: null) is documented as the convention for flat documents

- [ ] **Task 2: Build Riksdag HTML parser** (AC: 5)
  - [ ] Create `lib/transforms/parsers/riksdag-html-parser.ts`
  - [ ] Parse chapter headings from `<h3>` tags with `name="K1"` anchors (e.g., `<h3><a name="K1">1 kap.</a> Lagens ändamål</h3>`)
  - [ ] Parse paragraphs from `<a class="paragraf" name="K1P1">` anchors — extract chapter and paragraph number from the `name` attribute convention (K=kapitel, P=paragraf)
  - [ ] Parse sentence/stycke markers from `name="K1P1S2"` (S=stycke) for multi-paragraph sections
  - [ ] Handle laws without chapters: detect absence of `name="K1"` anchors, wrap all paragraphs in implicit chapter
  - [ ] Handle `2a §`, `2b §` numbering variants (common in Swedish law)
  - [ ] Extract övergångsbestämmelser (transition provisions) at end of document, outside chapter structure — assign role `TRANSITION_PROVISION`
  - [ ] Handle tables embedded in laws — assign role `TABLE`
  - [ ] Use cheerio for HTML parsing (already in project dependencies)

- [ ] **Task 3: Improve amendment HTML parser** (AC: 6)
  - [ ] Create `lib/transforms/parsers/amendment-html-parser.ts`
  - [ ] Parse semantic IDs like `id="SFS2025-732_K6_P17_S1"` — extract chapter (K6), paragraph (P17), sentence (S1)
  - [ ] Break existing chapter-level content blobs into paragraph-level entries in canonical schema
  - [ ] Preserve `changeType` metadata (`amended`, `new`, `repealed`) from existing HTML classes
  - [ ] Handle amendments to laws without chapters (no K prefix in IDs)
  - [ ] Map amendment-specific roles: footnotes, transition provisions

- [ ] **Task 4: Verify agency regulation parser** (AC: 7)
  - [ ] Create `lib/transforms/parsers/agency-html-parser.ts`
  - [ ] Parse `article.sfs` as document root
  - [ ] Parse `section.kapitel` as chapters — extract chapter number from heading
  - [ ] Parse `h3.paragraph` as section headings (e.g., "3 §")
  - [ ] Parse `p.text` as paragraph content — assign role `PARAGRAPH`
  - [ ] Parse `p.allmant-rad` or equivalent class as `ALLMANT_RAD` role
  - [ ] Handle tables (`table` elements within sections) — assign role `TABLE`
  - [ ] Handle footnote wrappers (`div.provision__dialog-wrapper`) — extract content, assign role `FOOTNOTE`
  - [ ] Adapt existing AFS HTML parsing patterns from `lib/agency/afs-html-transformer.ts` if applicable

- [ ] **Task 5: Refactor htmlToJson dispatcher** (AC: 8)
  - [ ] Update `lib/transforms/html-to-json.ts` to accept `contentType: ContentType` parameter
  - [ ] Add dispatcher logic: `SFS_LAW` → riksdag parser, `SFS_AMENDMENT` → amendment parser, `AGENCY_REGULATION` → agency parser
  - [ ] Ensure backward compatibility: if no contentType is provided, fall back to existing behavior or auto-detect
  - [ ] Export the canonical schema types from the module
  - [ ] Consider keeping old `LegalDocumentJson` types for backward compatibility with a deprecation note

- [ ] **Task 6: Update markdown derivation** (AC: 9)
  - [ ] Review `lib/transforms/html-to-markdown.ts` for all content types
  - [ ] Ensure chapter headings render as `## Kap 1: Title`
  - [ ] Ensure section headings render as `### 1 §`
  - [ ] Ensure paragraphs, tables, and allmänna råd render cleanly
  - [ ] Verify output for all three content types with sample documents
  - [ ] Fix any content-type-specific issues

- [ ] **Task 7: Build batch derivation script** (AC: 10-11)
  - [ ] Create `scripts/derive-json-md-content.ts`
  - [ ] Accept CLI flags: `--dry-run` (log only, no DB writes), `--limit N` (process first N documents), `--content-type SFS_LAW|SFS_AMENDMENT|AGENCY_REGULATION` (filter by type), `--resume` (restart from last cursor)
  - [ ] Query documents with `html_content IS NOT NULL` ordered by `id` for deterministic pagination
  - [ ] For each document: parse HTML → canonical JSON, derive markdown, validate JSON with schema validator
  - [ ] Update `json_content` and `markdown_content` in a single `prisma.legalDocument.update()`
  - [ ] Progress logging: `"[SFS_LAW] Processed 500/10,803 (4.6%) | Errors: 2 | Skipped: 0"`
  - [ ] Resume tracking: write last processed document ID to `data/derive-progress.json`
  - [ ] Error handling: log error with document ID and continue processing (do not abort batch)
  - [ ] Summary report at end: total processed, errors, skipped, duration

- [ ] **Task 8: Schema validation** (AC: 12)
  - [ ] Create `lib/transforms/validate-document-json.ts`
  - [ ] Define Zod schema matching the canonical TypeScript interfaces
  - [ ] Export `validateCanonicalJson(json: unknown): { valid: boolean, errors: string[] }`
  - [ ] Validate: chapters array exists, each chapter has sections, each section has paragraphs, roles are valid enum values
  - [ ] Return human-readable error messages for debugging

- [ ] **Task 9: Tests** (AC: 13)
  - [ ] Create `tests/unit/transforms/riksdag-html-parser.test.ts` — at least 8 tests
    - Law with chapters + paragraphs (happy path)
    - Law without chapters (flat structure → implicit chapter)
    - Paragraph with `2a §` numbering
    - Multiple sentences within a paragraph (S1, S2)
    - Övergångsbestämmelser extraction
    - Tables in law text
    - Empty/minimal HTML input
    - Real HTML sample from Riksdag API
  - [ ] Create `tests/unit/transforms/amendment-json-parser.test.ts` — at least 6 tests
    - Amendment with chapter-level changes
    - Amendment breaking chapter blobs into paragraphs
    - Amendment with new/repealed sections
    - Amendment without chapter structure
    - Transition provisions in amendments
    - Real HTML sample from amendment document
  - [ ] Create `tests/unit/transforms/agency-json-parser.test.ts` — at least 4 tests
    - Agency regulation with chapters and paragraphs
    - Agency regulation with allmänna råd sections
    - Agency regulation with tables
    - Flat agency regulation (no chapters)
  - [ ] Create `tests/unit/transforms/validate-document-json.test.ts` — at least 4 tests
    - Valid canonical JSON passes validation
    - Missing chapters array fails
    - Invalid role enum fails
    - Partial structure fails with specific error messages
  - [ ] Verify `npx tsc --noEmit` passes
  - [ ] Verify all existing tests still pass

## Dev Notes

### Source Tree

```
lib/transforms/
  ├── html-to-json.ts                    — EXISTING — refactor to dispatch by content type
  ├── html-to-markdown.ts                — EXISTING — review and update if needed
  ├── document-json-schema.ts            — NEW — canonical TypeScript interfaces + ContentRole enum
  ├── validate-document-json.ts          — NEW — Zod-based schema validation
  └── parsers/                           — NEW directory
      ├── riksdag-html-parser.ts         — NEW — SFS_LAW parser
      ├── amendment-html-parser.ts       — NEW — SFS_AMENDMENT parser
      └── agency-html-parser.ts          — NEW — AGENCY_REGULATION parser

scripts/
  └── derive-json-md-content.ts          — NEW — batch derivation script

data/
  └── derive-progress.json               — NEW — resume cursor (gitignored)
```

### Existing htmlToJson Interface (Current — to be replaced/extended)

```typescript
// lib/transforms/html-to-json.ts (current structure)
export interface LegalDocumentJson {
  type: 'amendment' | 'law' | 'regulation' | 'court_case' | 'eu_document'
  title: string | null
  metadata: DocumentMetadata
  sections: Section[]              // Flat section list — NOT hierarchical
  transitionProvisions: TransitionProvision[]
  footnotes: Footnote[]
  definitions: Definition[]
  legislativeReferences: LegislativeReference[]
}
```

This is a flat structure. The canonical schema replaces it with a chapter-first hierarchy.

### Canonical Schema (Target)

```typescript
// lib/transforms/document-json-schema.ts
export type ContentRole =
  | 'PARAGRAPH'
  | 'ALLMANT_RAD'
  | 'TABLE'
  | 'HEADING'
  | 'TRANSITION_PROVISION'
  | 'FOOTNOTE'

export interface CanonicalDocumentJson {
  /** Schema version for future compatibility */
  schemaVersion: '1.0'
  /** Content type from Prisma enum */
  documentType: 'SFS_LAW' | 'SFS_AMENDMENT' | 'AGENCY_REGULATION'
  /** Document title */
  title: string | null
  /** Document number (e.g., "SFS 1977:1160") */
  documentNumber: string | null
  /** Hierarchical chapter structure */
  chapters: CanonicalChapter[]
  /** Document-level metadata */
  metadata: {
    sfsNumber: string | null
    baseLawSfs: string | null
    effectiveDate: string | null
  }
}

export interface CanonicalChapter {
  /** Chapter number as string (e.g., "1", "2"). null for implicit chapter */
  number: string | null
  /** Chapter title (e.g., "Lagens ändamål"). null for implicit chapter */
  title: string | null
  /** Sections within this chapter (§ paragraphs) */
  sections: CanonicalSection[]
}

export interface CanonicalSection {
  /** Section number (e.g., "1", "2a", "15b") */
  number: string
  /** Section heading if present */
  heading: string | null
  /** Paragraphs (stycken) within this section */
  paragraphs: CanonicalParagraph[]
}

export interface CanonicalParagraph {
  /** Stycke number within the section (1, 2, 3...). null for non-numbered content */
  number: number | null
  /** Plain text content */
  text: string
  /** Content role */
  role: ContentRole
  /** Raw HTML for rendering (optional — only included if needed downstream) */
  htmlContent?: string
}
```

### Riksdag HTML Conventions

The Riksdag API returns HTML with anchor-based navigation. Key patterns:

```html
<!-- Chapter heading -->
<h3><a name="K1">1 kap.</a> Lagens tillampningsomrade och syfte</h3>

<!-- Paragraph (§) within a chapter -->
<a class="paragraf" name="K1P1"><b>1 &sect;</b></a>
&nbsp;&nbsp;Denna lag har till andamal att forebygga ohalsa och olycksfall...

<!-- Second stycke (sentence) within same § -->
<a name="K1P1S2"></a>Lagen galler aven...

<!-- Paragraph numbering variant -->
<a class="paragraf" name="K2P2a"><b>2 a &sect;</b></a>

<!-- Transition provisions (outside chapters, at end) -->
<h3>Overgångsbestammelser</h3>
<p>1. Denna lag trader i kraft den 1 januari 2025...</p>
```

Name attribute convention: `K` = kapitel (chapter), `P` = paragraf (section/§), `S` = stycke (sentence/paragraph within §).

### Amendment HTML Conventions

Amendment documents use semantic IDs for paragraph-level identification:

```html
<!-- Paragraph with semantic ID -->
<p class="text" id="SFS2025-732_K6_P17_S1">
  De som genomgar utbildning eller deltar i arbetsmarknadspolitiskt program...
</p>

<!-- Amendment markers in article elements -->
<article class="sfs" data-change-type="amended">
  <h2>6 kap. 17 &sect;</h2>
  <p class="text" id="SFS2025-732_K6_P17_S1">...</p>
  <p class="text" id="SFS2025-732_K6_P17_S2">...</p>
</article>
```

ID convention: `{SFS number}_{chapter}_{paragraph}_{sentence}` — e.g., `SFS2025-732_K6_P17_S1`.

### Agency Regulation HTML Conventions

Agency regulations use CSS classes for structure (from AFS HTML scraping pipeline):

```html
<article class="sfs">
  <section class="kapitel">
    <h2>1 kap. Tillampningsomrade</h2>
    <h3 class="paragraph">1 &sect;</h3>
    <p class="text">Dessa foreskrifter galler...</p>
    <p class="text">Foreskrifterna galler aven...</p>
    <p class="allmant-rad">Allmanna rad: Med arbetsplats avses...</p>
  </section>
</article>
```

### Scale & Performance Considerations

- **SFS Laws:** ~10,803 documents — bulk of the processing
- **SFS Amendments:** ~24,932 documents — many are short
- **Agency Regulations:** ~288 documents — smallest set
- Total: ~36,023 documents to process
- Batch script should process in pages of 100 to avoid memory issues
- Estimated runtime: 5-15 minutes for full batch (pure CPU, no API calls)

### LegalDocument Schema Reference

```prisma
model LegalDocument {
  id               String       @id @default(uuid())
  content_type     ContentType  // SFS_LAW, SFS_AMENDMENT, AGENCY_REGULATION
  document_number  String       @unique
  title            String
  html_content     String?      @db.Text  // SSOT — source HTML
  markdown_content String?      @db.Text  // Derived from HTML
  json_content     Json?                  // Derived from HTML — this story updates
  // ... other fields
  @@map("legal_documents")
}
```
[Source: prisma/schema.prisma:281-321]

### Import Aliases

Use `@/lib/transforms/...` for transform modules, `@/lib/prisma` for Prisma client. [Source: tsconfig.json path aliases]

## Testing

**Test location:** `tests/unit/transforms/` [mirroring `lib/transforms/` source structure]

**Test framework:** Vitest with no mocking needed — these are pure transform functions (HTML in, JSON out).

**Test files:**

- `tests/unit/transforms/riksdag-html-parser.test.ts` (at least 8 tests)
- `tests/unit/transforms/amendment-json-parser.test.ts` (at least 6 tests)
- `tests/unit/transforms/agency-json-parser.test.ts` (at least 4 tests)
- `tests/unit/transforms/validate-document-json.test.ts` (at least 4 tests)

**Riksdag parser tests:**
- Law with 3 chapters and multiple paragraphs → correct chapter/section/paragraph hierarchy
- Law without chapters (no K anchors) → single implicit chapter wrapping all sections
- Paragraph `2a §` numbering → section number = "2a"
- Multi-stycke paragraph (K1P1, K1P1S2, K1P1S3) → 3 paragraphs within section "1"
- Övergångsbestämmelser → extracted as section with role `TRANSITION_PROVISION`
- Table in law text → paragraph with role `TABLE`
- Empty HTML → returns empty chapters array
- Real Riksdag HTML snippet → validates against Zod schema

**Amendment parser tests:**
- Amendment with `K6_P17_S1` IDs → chapter 6, section 17, paragraph 1
- Amendment breaking chapter blob into paragraphs → multiple paragraphs per section
- New section (`data-change-type="new"`) → preserved in metadata
- Repealed section → preserved in metadata
- Amendment without chapters (no K prefix) → implicit chapter
- Transition provisions in amendment → role `TRANSITION_PROVISION`

**Agency parser tests:**
- Regulation with `section.kapitel` and `h3.paragraph` → chapters and sections
- Allmänna råd paragraphs → role `ALLMANT_RAD`
- Table within section → role `TABLE`
- Flat regulation (no kapitel) → implicit chapter

**Validation tests:**
- Valid canonical JSON → `{ valid: true, errors: [] }`
- Missing `chapters` → `{ valid: false, errors: ["..."] }`
- Invalid `role` value → specific error message
- Nested structure with one invalid paragraph → error identifies path

**Pattern:** Pure function tests — no database, no mocking. Input HTML string, assert output JSON structure. Use inline HTML strings for test fixtures (keep tests self-contained).

## Change Log

| Date       | Version | Description            | Author     |
| ---------- | ------- | ---------------------- | ---------- |
| 2026-02-18 | 1.0     | Initial story creation | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

### Debug Log References

### Completion Notes List

### File List

## QA Results
