# Story 13.2: ELI URI Resolution Routes

## Status

Draft

## Story

**As a** European legal data aggregator, AI agent, or linked-data consumer,
**I want** to resolve ELI URIs for Swedish legislation on Laglig.se via standard HTTP,
**so that** I can dereference legislation identifiers to their canonical document pages following the ELI standard.

## Context

ELI Pillar 1 requires that each legal text has a unique, human-readable URI that resolves via HTTP. The URI should be persistent (never changes) and redirect to the canonical page for that legislation.

Story 13.1 mints ELI URIs as `@id` in JSON-LD. This story makes those URIs actually **resolvable** — when someone or something requests `https://laglig.se/eli/se/sfs/2005/551`, they get an HTTP 303 redirect to `/lagar/aktiebolagslag-2005-551`.

Additionally, each document page gets a `<link rel="alternate">` tag pointing to its ELI URI, establishing the bidirectional relationship between canonical page and persistent identifier.

### ELI URI Patterns

```
/eli/se/sfs/{year}/{number}              → SFS laws and amendments
/eli/se/{agency-prefix}/{year}/{number}  → Agency regulations (afs, msbfs, nfs, etc.)
/eli/eu/reg/{year}/{number}              → EU regulations
/eli/eu/dir/{year}/{number}              → EU directives
```

### Why HTTP 303?

The ELI specification recommends HTTP 303 (See Other) rather than 301/302 because it semantically means "the resource you asked about can be found at this other location" — appropriate when the URI identifies a conceptual resource (the law itself) and the redirect target is a representation (an HTML page about the law).

## Acceptance Criteria

### AC1: ELI Route Handler

1. A catch-all route at `/eli/[...segments]` parses the URI components and resolves to a target document
2. Successful resolution returns HTTP 303 redirect to the canonical document page URL
3. Unknown/invalid ELI URIs return HTTP 404 with an appropriate error page
4. Route handles all document types: SFS laws, SFS amendments, agency regulations, EU regulations, EU directives

### AC2: Document Resolution Logic

5. SFS URIs (`/eli/se/sfs/{year}/{number}`) resolve by constructing `document_number = "SFS {year}:{number}"` and looking up the document's slug
6. Agency regulation URIs (`/eli/se/{prefix}/{year}/{number}`) resolve by constructing `document_number = "{PREFIX} {year}:{number}"` (uppercased prefix, handling hyphenated variants like `elsak-fs` → `ELSÄK-FS`)
7. EU URIs (`/eli/eu/reg/{year}/{number}` and `/eli/eu/dir/{year}/{number}`) resolve by searching for matching CELEX number or document_number
8. Resolution uses a database lookup (single query, indexed on `document_number`)

### AC3: Link Alternate Headers

9. Each public document page includes `<link rel="alternate" type="application/eli+json" href="{eli-uri}">` in the HTML `<head>` for legislation documents
10. Court case pages do NOT get ELI alternate links (they are not legislation)

### AC4: Testing

11. Unit tests cover URI parsing for all document types (valid and invalid patterns)
12. Unit tests verify document_number construction from URI components
13. Tests verify 303 redirect behavior and 404 for unknown documents

## Tasks / Subtasks

- [ ] **Task 1: Create ELI URI parser** (AC: 1, 4)
  - [ ] Create `lib/eli/parse-eli-uri.ts` with `parseEliUri(segments: string[])` function
  - [ ] Parse `/se/sfs/{year}/{number}` → `{ jurisdiction: 'se', type: 'sfs', year, number }`
  - [ ] Parse `/se/{agency-prefix}/{year}/{number}` → `{ jurisdiction: 'se', type: 'agency', prefix, year, number }`
  - [ ] Parse `/eu/reg/{year}/{number}` and `/eu/dir/{year}/{number}` → `{ jurisdiction: 'eu', type: 'reg'|'dir', year, number }`
  - [ ] Return `null` for invalid/unrecognized patterns
  - [ ] Unit tests for all patterns + edge cases

- [ ] **Task 2: Create document_number resolution** (AC: 5-8)
  - [ ] Create `lib/eli/resolve-eli-document.ts` with `resolveEliDocument(parsed)` function
  - [ ] SFS: construct `"SFS {year}:{number}"`, query `LegalDocument` by `document_number`
  - [ ] Agency: map lowercase prefix to canonical form (e.g., `afs` → `AFS`, `elsak-fs` → `ELSÄK-FS`), construct `"{PREFIX} {year}:{number}"`
  - [ ] EU: construct potential CELEX number or search by pattern
  - [ ] Return `{ slug, contentType }` or `null` if not found
  - [ ] Unit tests with mocked Prisma

- [ ] **Task 3: Create catch-all route handler** (AC: 1-3)
  - [ ] Create `app/eli/[...segments]/route.ts` (Route Handler, not page)
  - [ ] Parse segments with `parseEliUri()`
  - [ ] Resolve with `resolveEliDocument()`
  - [ ] Return `NextResponse.redirect(canonicalUrl, 303)` on success
  - [ ] Return `NextResponse.json({ error: 'Not found' }, { status: 404 })` on failure

- [ ] **Task 4: Add `<link rel="alternate">` to document pages** (AC: 9-10)
  - [ ] Add ELI alternate link to `generateMetadata()` in `app/(public)/lagar/[id]/page.tsx`
  - [ ] Add ELI alternate link to `generateMetadata()` in `app/(public)/foreskrifter/[slug]/page.tsx`
  - [ ] Add ELI alternate link to `generateMetadata()` in `app/(public)/eu/[type]/[id]/page.tsx`
  - [ ] Do NOT add to court case pages

## Dev Notes

### Relevant Source Tree

```
app/eli/[...segments]/route.ts                — NEW: ELI catch-all route handler
lib/eli/parse-eli-uri.ts                      — NEW: URI component parser
lib/eli/resolve-eli-document.ts               — NEW: document_number lookup
lib/eli/build-eli-uri.ts                      — FROM STORY 13.1: URI minting (reuse for <link> tags)
lib/prefetch/get-document-url.ts              — Existing URL routing (used for redirect targets)
app/(public)/lagar/[id]/page.tsx              — Add <link rel="alternate"> via generateMetadata()
app/(public)/foreskrifter/[slug]/page.tsx     — Add <link rel="alternate"> via generateMetadata()
app/(public)/eu/[type]/[id]/page.tsx          — Add <link rel="alternate"> via generateMetadata()
```

### Agency Prefix Normalization

The URI uses lowercase ASCII, but document_numbers use uppercase with Swedish characters:

| URI prefix | document_number prefix |
|------------|----------------------|
| `afs` | `AFS` |
| `msbfs` | `MSBFS` |
| `nfs` | `NFS` |
| `tsfs` | `TSFS` |
| `elsak-fs` | `ELSÄK-FS` |
| `bfs` | `BFS` |
| `kifs` | `KIFS` |
| `skvfs` | `SKVFS` |
| `scb-fs` | `SCB-FS` |
| `stafs` | `STAFS` |
| `ssmfs` | `SSMFS` |
| `srvfs` | `SRVFS` |

Create a reverse map from URI-safe prefix to canonical prefix. This can live alongside the `AGENCY_PUBLISHER_MAP` from Story 13.1.

### Next.js Route Handler Pattern

Use a Route Handler (not a page component) for the redirect:

```typescript
// app/eli/[...segments]/route.ts
import { NextRequest, NextResponse } from 'next/server'

export async function GET(
  _request: NextRequest,
  { params }: { params: Promise<{ segments: string[] }> }
) {
  const { segments } = await params
  // Parse → Resolve → Redirect or 404
}
```

### Adding `<link>` via generateMetadata()

Next.js `generateMetadata()` supports `alternates`:

```typescript
export async function generateMetadata(): Promise<Metadata> {
  return {
    // ... existing metadata
    alternates: {
      types: {
        'application/eli+json': buildEliUri(doc),
      },
    },
  }
}
```

### EU CELEX Number Parsing

To resolve `/eli/eu/reg/2016/679` → the correct document, we need to find a document with CELEX `32016R0679` or `document_number` matching. CELEX pattern: `3{YYYY}{R|L}{NNNN}` where R=Regulation, L=Directive.

```typescript
function buildCelexSearch(type: 'reg' | 'dir', year: string, number: string): string {
  const typeCode = type === 'reg' ? 'R' : 'L'
  return `3${year}${typeCode}${number.padStart(4, '0')}`
}
```

### Depends On

- **Story 13.1** — for `buildEliUri()` function and `lib/eli/` module structure

### Testing

- **Test location**: `tests/unit/lib/eli/`
- **Framework**: Vitest
- **Key test files**:
  - `parse-eli-uri.test.ts` — URI parsing for all patterns, invalid input, edge cases
  - `resolve-eli-document.test.ts` — document_number construction, agency prefix normalization (mock Prisma)
- **Route handler testing**: Manual verification via browser/curl — `curl -I https://laglig.se/eli/se/sfs/2005/551` should return 303

## Dev Agent Record

### Agent Model Used

_To be filled during implementation_

### Debug Log References

_To be filled during implementation_

### Completion Notes List

_To be filled during implementation_

### File List

_To be filled during implementation_

## QA Results

_To be populated by QA agent after implementation review._

## Change Log

| Date | Version | Description | Author |
| --- | --- | --- | --- |
| 2026-02-13 | 1.0 | Initial story draft | Sarah (PO) |
