# Story 5.10: Implement Unit Economics Tracking (NFR18 - CRITICAL)

## Status

Draft

## Story

**As a** product owner,
**I want** to track costs per workspace to validate business model,
**so that** I ensure gross margin >80%.

## Context & Dependencies

- **Builds on:** Story 5.4 (Stripe billing) — needs subscription tier info for revenue calculation
- **Builds on:** Story 3.3 (completed) — AI chat infrastructure (where API costs are incurred)
- **Note:** The project uses **Anthropic Claude** (not OpenAI) for all AI features. Pricing must reflect Claude model costs.
- **Note:** Cron jobs use Vercel cron route handlers, not `node-cron`.

## Acceptance Criteria

1. `workspace_costs` table tracks: workspace_id, month, ai_api_cost, vector_query_cost, storage_cost, total_cost
2. AI API costs logged per query (Anthropic Claude pricing)
3. Vector query costs calculated (Supabase pricing or estimated)
4. Storage costs calculated based on GB used
5. Monthly Vercel cron job aggregates costs per workspace
6. Analytics dashboard shows:
   - Revenue per workspace (subscription MRR)
   - Cost per workspace (AI + storage)
   - Gross margin % (target >80%)
   - Cohort analysis: Margin by tier (Solo vs Team vs Enterprise)
7. Email report sent to founder weekly via Resend
8. Alerting: If any workspace margin <60%, flag for review
9. Cost optimization recommendations: "Switch to Haiku for workspace X"

## Tasks / Subtasks

- [ ] Create `WorkspaceCost` and `ApiCostLog` Prisma models
- [ ] Define Anthropic Claude pricing constants
- [ ] Log AI API costs per chat query
- [ ] Calculate vector query costs
- [ ] Calculate storage costs
- [ ] Create monthly cost aggregation Vercel cron route
- [ ] Build unit economics admin dashboard
- [ ] Implement weekly email report via Resend
- [ ] Add alerting for low-margin workspaces
- [ ] Generate cost optimization recommendations

## Dev Notes

**Database Schema:**

```prisma
model WorkspaceCost {
  id               String   @id @default(uuid())
  workspaceId      String
  month            DateTime // First day of month
  aiApiCost        Float    @default(0) // EUR
  vectorQueryCost  Float    @default(0) // EUR
  storageCost      Float    @default(0) // EUR
  totalCost        Float    @default(0) // EUR
  revenue          Float    @default(0) // EUR (subscription MRR)
  grossMargin      Float?   // %
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@unique([workspaceId, month])
  @@index([month])
  @@map("workspace_costs")
}

model ApiCostLog {
  id              String   @id @default(uuid())
  workspaceId     String
  endpoint        String   // /api/chat/query, etc.
  model           String   // claude-sonnet-4-6, claude-haiku-4-5, etc.
  inputTokens     Int
  outputTokens    Int
  cost            Float    // EUR calculated based on model pricing
  timestamp       DateTime @default(now())

  @@index([workspaceId, timestamp])
  @@map("api_cost_logs")
}
```

**Anthropic Claude Pricing Constants:**

```typescript
// lib/costs/pricing.ts

// Anthropic Claude pricing (as of February 2026)
// See: https://www.anthropic.com/pricing
export const ANTHROPIC_PRICING: Record<string, { input: number; output: number }> = {
  'claude-opus-4-6': {
    input: 15.0 / 1_000_000,   // $15 per 1M input tokens
    output: 75.0 / 1_000_000,  // $75 per 1M output tokens
  },
  'claude-sonnet-4-6': {
    input: 3.0 / 1_000_000,    // $3 per 1M input tokens
    output: 15.0 / 1_000_000,  // $15 per 1M output tokens
  },
  'claude-haiku-4-5': {
    input: 0.80 / 1_000_000,   // $0.80 per 1M input tokens
    output: 4.0 / 1_000_000,   // $4 per 1M output tokens
  },
}

// USD to EUR conversion (approximate, update periodically)
const USD_TO_EUR = 0.92

// Supabase pricing (estimated)
export const VECTOR_QUERY_COST_PER_QUERY = 0.0001 // EUR per query

// Storage pricing (estimated)
export const STORAGE_COST_PER_GB_MONTH = 0.02 // EUR per GB per month

export function calculateAICost(
  model: string,
  inputTokens: number,
  outputTokens: number
): number {
  const pricing = ANTHROPIC_PRICING[model]
  if (!pricing) {
    console.warn(`Unknown model pricing: ${model}, using Sonnet as fallback`)
    const fallback = ANTHROPIC_PRICING['claude-sonnet-4-6']
    return (fallback.input * inputTokens + fallback.output * outputTokens) * USD_TO_EUR
  }

  return (pricing.input * inputTokens + pricing.output * outputTokens) * USD_TO_EUR
}
```

**Log AI API Cost:**

```typescript
// lib/costs/log-api-cost.ts
import { prisma } from '@/lib/prisma'
import { calculateAICost } from './pricing'

export async function logAPICost({
  workspaceId,
  endpoint,
  model,
  inputTokens,
  outputTokens,
}: {
  workspaceId: string
  endpoint: string
  model: string
  inputTokens: number
  outputTokens: number
}) {
  const cost = calculateAICost(model, inputTokens, outputTokens)

  await prisma.apiCostLog.create({
    data: {
      workspaceId,
      endpoint,
      model,
      inputTokens,
      outputTokens,
      cost,
    },
  })

  return cost
}
```

**Usage in AI Chat Route:**

```typescript
// In the existing chat API route, after calling Anthropic:
import { logAPICost } from '@/lib/costs/log-api-cost'

// After getting the response from Claude:
const usage = response.usage // { input_tokens, output_tokens }

await logAPICost({
  workspaceId: context.workspaceId,
  endpoint: '/api/chat/query',
  model: 'claude-sonnet-4-6', // or whichever model is used
  inputTokens: usage.input_tokens,
  outputTokens: usage.output_tokens,
})
```

**Monthly Cost Aggregation (Vercel Cron):**

```typescript
// app/api/cron/aggregate-costs/route.ts
import { NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { VECTOR_QUERY_COST_PER_QUERY, STORAGE_COST_PER_GB_MONTH } from '@/lib/costs/pricing'
import { sendHtmlEmail } from '@/lib/email/email-service'

export const dynamic = 'force-dynamic'
export const maxDuration = 300

const CRON_SECRET = process.env.CRON_SECRET

export async function GET(request: Request) {
  const authHeader = request.headers.get('authorization')
  if (process.env.NODE_ENV !== 'development' && CRON_SECRET && authHeader !== `Bearer ${CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const startTime = Date.now()
  console.log('[AGGREGATE-COSTS] Starting monthly cost aggregation...')

  const now = new Date()
  const lastMonth = new Date(now.getFullYear(), now.getMonth() - 1, 1)
  const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 1)

  const workspaces = await prisma.workspace.findMany({
    where: { status: 'ACTIVE' },
  })

  const results = []

  for (const workspace of workspaces) {
    // Aggregate AI API costs for last month
    const aiCosts = await prisma.apiCostLog.aggregate({
      where: {
        workspaceId: workspace.id,
        timestamp: { gte: lastMonth, lt: lastMonthEnd },
      },
      _sum: { cost: true },
      _count: true,
    })

    const aiApiCost = aiCosts._sum.cost || 0
    const queryCount = aiCosts._count || 0

    // Vector query costs (estimate based on AI query count)
    const vectorQueryCost = queryCount * VECTOR_QUERY_COST_PER_QUERY

    // Storage costs (estimate from workspace files)
    const storageStats = await prisma.workspaceFile.aggregate({
      where: { workspace_id: workspace.id, is_folder: false },
      _sum: { file_size: true },
    })
    const storageGB = ((storageStats._sum.file_size || 0) / 1024 / 1024 / 1024)
    const storageCost = storageGB * STORAGE_COST_PER_GB_MONTH

    const totalCost = aiApiCost + vectorQueryCost + storageCost
    const revenue = getTierMRR(workspace.subscription_tier)
    const grossMargin = revenue > 0 ? ((revenue - totalCost) / revenue) * 100 : 0

    await prisma.workspaceCost.upsert({
      where: { workspaceId_month: { workspaceId: workspace.id, month: lastMonth } },
      update: { aiApiCost, vectorQueryCost, storageCost, totalCost, revenue, grossMargin },
      create: {
        workspaceId: workspace.id,
        month: lastMonth,
        aiApiCost, vectorQueryCost, storageCost, totalCost, revenue, grossMargin,
      },
    })

    results.push({
      workspaceId: workspace.id,
      name: workspace.name,
      tier: workspace.subscription_tier,
      revenue, totalCost, grossMargin,
    })

    if (grossMargin < 60 && revenue > 0) {
      console.warn(`[AGGREGATE-COSTS] Low margin alert: ${workspace.name} = ${grossMargin.toFixed(1)}%`)
    }
  }

  const duration = `${Math.round((Date.now() - startTime) / 1000)}s`
  console.log(`[AGGREGATE-COSTS] Completed in ${duration}, processed ${results.length} workspaces`)

  return NextResponse.json({ success: true, duration, workspaces: results.length })
}

function getTierMRR(tier: string): number {
  const mrr: Record<string, number> = {
    TRIAL: 0,
    SOLO: 399,
    TEAM: 899,
    ENTERPRISE: 2000,
  }
  return mrr[tier] || 0
}
```

Add to `vercel.json`:
```json
{ "path": "/api/cron/aggregate-costs", "schedule": "0 3 1 * *" }
```

**Weekly Report Email (Vercel Cron):**

```typescript
// app/api/cron/unit-economics-report/route.ts
export const dynamic = 'force-dynamic'
export const maxDuration = 60

export async function GET(request: Request) {
  // ... auth check ...

  const latestMonth = new Date(new Date().getFullYear(), new Date().getMonth() - 1, 1)
  const costs = await prisma.workspaceCost.findMany({
    where: { month: latestMonth },
    include: { workspace: { select: { name: true, subscription_tier: true } } },
  })

  const totalMRR = costs.reduce((sum, c) => sum + c.revenue, 0)
  const totalCosts = costs.reduce((sum, c) => sum + c.totalCost, 0)
  const avgMargin = costs.length > 0
    ? costs.reduce((sum, c) => sum + (c.grossMargin || 0), 0) / costs.length
    : 0
  const lowMargin = costs.filter((c) => c.grossMargin !== null && c.grossMargin < 60)

  await sendHtmlEmail({
    to: process.env.FOUNDER_EMAIL || process.env.CRON_NOTIFICATION_EMAIL!,
    subject: `Unit Economics Report - ${latestMonth.toLocaleDateString('sv-SE')}`,
    html: `<h2>Veckorapport: Enhetsekonomi</h2>
      <p><strong>Snittmarginal:</strong> ${avgMargin.toFixed(1)}% (mal: >80%)</p>
      <p><strong>Total MRR:</strong> EUR ${totalMRR.toFixed(0)}</p>
      <p><strong>Totala kostnader:</strong> EUR ${totalCosts.toFixed(0)}</p>
      <p><strong>Lag marginal (<60%):</strong> ${lowMargin.length} workspaces</p>`,
    from: 'cron',
  })

  return NextResponse.json({ success: true })
}
```

Add to `vercel.json`:
```json
{ "path": "/api/cron/unit-economics-report", "schedule": "0 9 * * 1" }
```

**Reference:** PRD Epic 5 Story 5.10 (NFR18), `lib/email/email-service.ts`

## Testing

**Unit Tests:**

- `calculateAICost()` returns correct cost for each Claude model
- USD-to-EUR conversion applied correctly
- Unknown model falls back to Sonnet pricing with warning
- Cost aggregation sums correctly
- Gross margin calculation is accurate

**Integration Tests:**

- Log AI query, verify ApiCostLog record created
- Run monthly aggregation, verify WorkspaceCost record created
- Low margin alert triggered when margin <60%
- Weekly email report sends successfully

**Performance Tests:**

- Cost logging does not add measurable latency to chat queries
- Monthly aggregation completes within 5 minutes for 1000 workspaces

**Test File:** `tests/unit/costs/unit-economics.test.ts`

## Change Log

| Date       | Version | Description                                                  | Author     |
| ---------- | ------- | ------------------------------------------------------------ | ---------- |
| 2025-11-12 | 1.0     | Initial story creation                                       | Sarah (PO) |
| 2026-02-19 | 2.0     | Updated to Anthropic/Claude pricing, Vercel cron, Resend email | Sarah (PO) |

## Dev Agent Record

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
