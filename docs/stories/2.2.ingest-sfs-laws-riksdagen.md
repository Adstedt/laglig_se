# Story 2.2: Ingest 11,351 SFS Laws from Riksdagen API

## Status
Draft

## Story

**As a** developer,
**I want** to fetch all SFS laws from Riksdagen API and store them in the database,
**so that** we have complete Swedish legal content for the platform.

## Acceptance Criteria

1. Node script created to fetch all SFS documents from Riksdagen API
2. Script fetches: title, SFS number, full text, published date, ministry, metadata
3. Rate limiting implemented (conservative 5 requests/second)
4. Data stored in `legal_documents` table with content_type = SFS_LAW
5. SFS-specific metadata stored in `metadata` JSONB field
6. Script handles pagination for 11,351 documents (1968-present)
7. Duplicate detection: Skip laws already in database
8. Error handling: Retry failed requests 3x before logging to Sentry
9. Progress logging: "Processed 5,000/11,351 laws..."
10. Script completes in <48 hours (~38 hours estimated)
11. Verification: Database contains 11,351 SFS documents
12. Amendment extraction: Parse inline amendment references, create Amendment records
13. Amendment backfill from lagen.nu (background job)
14. GPT-4 summaries for amendments (~$238 one-time cost)
15. Database contains 90,000+ Amendment records with all 7 fields
16. Performance impact: +1.6 hours parsing, +1.3 hours backfill
17. Database impact: +90,000 records (~45MB storage)

## Tasks / Subtasks

- [ ] Create ingestion script (AC: 1, 2)
  - [ ] Create `scripts/ingest-sfs-laws.ts`
  - [ ] Configure Riksdagen API endpoint
  - [ ] Parse response structure (XML/JSON)
  - [ ] Extract: title, SFS number, full text, dates, ministry

- [ ] Implement rate limiting (AC: 3)
  - [ ] Use p-limit or bottleneck library
  - [ ] 5 requests/second maximum
  - [ ] Respect API guidelines

- [ ] Store in database (AC: 4, 5, 6)
  - [ ] Insert into `legal_documents` table
  - [ ] Set content_type = SFS_LAW
  - [ ] Store ministry, law_type in metadata JSONB
  - [ ] Handle pagination for 11,351 documents

- [ ] Add duplicate detection (AC: 7)
  - [ ] Check if document_number exists before insert
  - [ ] Skip if already present
  - [ ] Log skipped duplicates

- [ ] Implement error handling (AC: 8, 9)
  - [ ] Retry failed requests 3x
  - [ ] Log errors to Sentry
  - [ ] Progress logging every 100 documents

- [ ] Extract amendments (AC: 12, 14, 15)
  - [ ] Parse inline references: "Lag (2021:1112)"
  - [ ] Create Amendment records
  - [ ] Parse affected sections: "föreskrivs att 1 kap. 3 § ska ha följande lydelse"
  - [ ] Generate GPT-4 summaries (Swedish, 2-3 sentences)
  - [ ] Parse effective dates from transition provisions
  - [ ] Store all 7 fields per amendment

- [ ] Implement lagen.nu backfill (AC: 13, 16)
  - [ ] Scrape lagen.nu for laws with <5 amendments
  - [ ] Rate limit: 1 request per 2 seconds
  - [ ] Run as separate background job
  - [ ] Does not block main ingestion

- [ ] Verify completion (AC: 10, 11, 17)
  - [ ] Check database count: 11,351 SFS laws
  - [ ] Check amendment count: 90,000+ records
  - [ ] Sample verification of amendment data quality
  - [ ] Measure actual completion time

## Dev Notes

### Riksdagen API Integration

**API Endpoint:**
```
https://data.riksdagen.se/dokumentlista/?doktyp=sfs&utformat=json&p={page}
```

**Script Structure:**
```typescript
// scripts/ingest-sfs-laws.ts
import { prisma } from '@/lib/prisma'
import pLimit from 'p-limit'

const limit = pLimit(5) // 5 concurrent requests max

async function ingestSFSLaws() {
  let page = 1
  let totalProcessed = 0

  while (true) {
    const response = await fetch(
      `https://data.riksdagen.se/dokumentlista/?doktyp=sfs&utformat=json&p=${page}`
    )
    const data = await response.json()

    if (!data.dokumentlista?.dokument?.length) break

    const promises = data.dokumentlista.dokument.map((doc: any) =>
      limit(() => processSFSLaw(doc))
    )

    await Promise.all(promises)
    totalProcessed += promises.length

    console.log(`Processed ${totalProcessed}/11,351 laws...`)
    page++
  }

  console.log('✅ SFS ingestion complete')
}

async function processSFSLaw(doc: any) {
  // Check for duplicate
  const existing = await prisma.legalDocument.findUnique({
    where: { documentNumber: doc.beteckning },
  })

  if (existing) return

  // Insert law
  const law = await prisma.legalDocument.create({
    data: {
      contentType: 'SFS_LAW',
      documentNumber: doc.beteckning,
      title: doc.titel,
      fullText: doc.html, // Fetch full text separately
      publicationDate: new Date(doc.publicerad),
      sourceUrl: doc.dokument_url_html,
      metadata: {
        ministry: doc.organ,
        lawType: doc.subtyp,
      },
    },
  })

  // Extract and create amendments
  await extractAmendments(law)
}

async function extractAmendments(law: LegalDocument) {
  // Parse inline amendment references
  const regex = /Lag \((\d{4}):(\d+)\)/g
  const matches = [...law.fullText.matchAll(regex)]

  for (const match of matches) {
    const amendingLawNumber = `SFS ${match[1]}:${match[2]}`

    // Find amending law in database
    const amendingLaw = await prisma.legalDocument.findUnique({
      where: { documentNumber: amendingLawNumber },
    })

    if (!amendingLaw) continue

    // Parse affected sections
    const affectedSections = parseAffectedSections(amendingLaw.fullText)

    // Generate GPT-4 summary
    const summary = await generateAmendmentSummary(
      law.title,
      amendingLaw.title,
      affectedSections
    )

    // Parse effective date
    const effectiveDate = parseEffectiveDate(amendingLaw.fullText)

    // Create amendment record
    await prisma.amendment.create({
      data: {
        baseDocumentId: law.id,
        amendingDocumentId: amendingLaw.id,
        amendingLawTitle: amendingLaw.title,
        publicationDate: amendingLaw.publicationDate,
        effectiveDate,
        affectedSectionsRaw: formatAffectedSectionsRaw(affectedSections),
        affectedSections: affectedSections,
        summary,
        summaryGeneratedBy: 'GPT_4',
        detectedMethod: 'RIKSDAGEN_TEXT_PARSING',
      },
    })
  }
}

async function generateAmendmentSummary(
  baseLawTitle: string,
  amendingLawTitle: string,
  affectedSections: any
): Promise<string> {
  const prompt = `Sammanfatta denna lagändring på svenska i 2-3 meningar för icke-jurister:

Grundlag: ${baseLawTitle}
Ändrande lag: ${amendingLawTitle}
Berörda paragrafer: ${JSON.stringify(affectedSections)}

Svara endast med sammanfattningen, inga förklaringar.`

  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [{ role: 'user', content: prompt }],
    max_tokens: 150,
  })

  return response.choices[0].message.content || ''
}

function parseAffectedSections(text: string): any {
  // Parse Swedish legal text for section references
  // Example: "föreskrivs att 1 kap. 3 § ska ha följande lydelse"
  const amended = []
  const repealed = []
  const newSections = []

  // Regex patterns for Swedish legal language
  const amendPattern = /(?:ändras|ska ha följande lydelse).*?(\d+)\s*kap\.\s*(\d+)\s*§/gi
  const repealPattern = /(?:upphävs|ska upphöra att gälla).*?(\d+)\s*kap\.\s*(\d+)\s*§/gi

  // Extract amended sections
  for (const match of text.matchAll(amendPattern)) {
    amended.push(`${match[1]}:${match[2]}`)
  }

  // Extract repealed sections
  for (const match of text.matchAll(repealPattern)) {
    repealed.push(`${match[1]}:${match[2]}`)
  }

  return { amended, repealed, new: newSections, renumbered: [] }
}

function parseEffectiveDate(text: string): Date | null {
  // Parse: "träder i kraft den 1 juli 2011"
  const regex = /träder i kraft den (\d{1,2}) (\w+) (\d{4})/i
  const match = text.match(regex)

  if (!match) return null

  const months: Record<string, number> = {
    januari: 0, februari: 1, mars: 2, april: 3,
    maj: 4, juni: 5, juli: 6, augusti: 7,
    september: 8, oktober: 9, november: 10, december: 11,
  }

  const day = parseInt(match[1])
  const month = months[match[2].toLowerCase()]
  const year = parseInt(match[3])

  return new Date(year, month, day)
}
```

### Lagen.nu Backfill Script

```typescript
// scripts/backfill-amendments-lagen-nu.ts
async function backfillAmendments() {
  // Find laws with <5 amendments (suspected incomplete)
  const laws = await prisma.legalDocument.findMany({
    where: {
      contentType: 'SFS_LAW',
      amendments: {
        count: { lt: 5 },
      },
    },
  })

  for (const law of laws) {
    await sleep(2000) // 1 request per 2 seconds

    const url = `https://lagen.nu/${law.documentNumber.replace('SFS ', '')}`
    const html = await fetch(url).then(res => res.text())

    // Parse amendment list from lagen.nu HTML
    const amendments = parseAgenNuAmendments(html)

    // Create missing amendment records
    for (const amendment of amendments) {
      await createAmendmentIfMissing(law.id, amendment)
    }
  }
}
```

### Cost Analysis

**GPT-4 Amendment Summaries:**
- 5,675 amending laws (estimated)
- Average 150 tokens per summary
- Cost: $0.042/amendment × 5,675 = $238 one-time

**Storage:**
- 90,000 amendment records
- ~500 bytes per record
- ~45MB total

### Important Architecture References

**From External APIs docs (riksdagen-api-comprehensive-analysis.md):**
- Section 12: Production-ready implementation code
- Section 7: Amendment tracking strategies
- Section 5: Data volume estimates

**From docs/historical-amendment-tracking-strategy.md:**
- Complete amendment extraction implementation
- 7-field data model specification
- Competitive analysis vs Notisum

### Testing

**Test File:** `tests/integration/ingestion/sfs-laws.test.ts`

```typescript
describe('SFS Law Ingestion', () => {
  it('fetches and stores SFS law correctly', async () => {
    await ingestSingleSFSLaw('1977:1160') // Arbetsmiljölagen

    const law = await prisma.legalDocument.findUnique({
      where: { documentNumber: 'SFS 1977:1160' },
    })

    expect(law).toBeDefined()
    expect(law?.title).toContain('Arbetsmiljölagen')
  })

  it('extracts amendments from law text', async () => {
    const law = await createTestLaw()
    await extractAmendments(law)

    const amendments = await prisma.amendment.findMany({
      where: { baseDocumentId: law.id },
    })

    expect(amendments.length).toBeGreaterThan(0)
    expect(amendments[0].summary).toBeDefined()
  })

  it('handles duplicate detection', async () => {
    await ingestSingleSFSLaw('1977:1160')
    await ingestSingleSFSLaw('1977:1160') // Duplicate

    const count = await prisma.legalDocument.count({
      where: { documentNumber: 'SFS 1977:1160' },
    })

    expect(count).toBe(1)
  })
})
```

### User Responsibilities
- None (fully automated ingestion)

### Developer Responsibilities
- Run ingestion script
- Monitor progress and errors
- Verify data quality after completion
- Manage OpenAI API costs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-11 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
