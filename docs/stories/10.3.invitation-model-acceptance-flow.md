# Story 10.3: Invitation Model & Acceptance Flow

## Status

Draft

## Story

**As a** user who has been invited to a workspace,
**I want** to see and accept my pending invitation(s) during onboarding,
**so that** I can join an existing workspace without creating a new one.

## Acceptance Criteria

**Database Model:**

1. New `WorkspaceInvitation` model in Prisma with fields: `id` (UUID), `workspace_id`, `email`, `role` (WorkspaceRole), `token` (unique), `invited_by`, `status` (PENDING/ACCEPTED/EXPIRED/REVOKED), `expires_at`, `created_at`
2. Database migration creates `workspace_invitations` table with indexes on `email`, `token`, and `workspace_id`
3. `InvitationStatus` enum added to Prisma schema: `PENDING`, `ACCEPTED`, `EXPIRED`, `REVOKED`
4. Invitation tokens are cryptographically secure — minimum 32 bytes, URL-safe base64 encoded

**Invitation Detection During Onboarding:**

5. When a user without a workspace arrives at `/onboarding`, the system queries for pending, non-expired `WorkspaceInvitation` records matching the user's email
6. Expired invitations (past `expires_at`) are automatically marked as `EXPIRED` when detected and not shown to the user
7. If pending invitations exist, they are displayed instead of the workspace creation wizard

**Invitation UI:**

8. Each pending invitation is shown as a card with: workspace name, assigned role (in Swedish), inviter name, expiry date ("Gäller till: YYYY-MM-DD")
9. Each card has "Acceptera" (primary) and "Avböj" (secondary/outline) action buttons
10. Below the invitation cards, a "Skapa eget workspace istället" link allows the user to dismiss invitations and proceed to the workspace creation wizard
11. All text is in Swedish

**Accept Flow:**

12. Accepting an invitation creates a `WorkspaceMember` record with the role specified in the invitation
13. The invitation status is updated to `ACCEPTED`
14. The active workspace cookie is set to the accepted workspace
15. The user's workspace context cache in Redis is invalidated
16. User is redirected to `/dashboard` (or `?redirect=` URL if present)

**Decline Flow:**

17. Declining an invitation marks it as `REVOKED`
18. If more pending invitations remain, the next one is shown
19. If no more pending invitations, the workspace creation wizard is shown

**Edge Cases:**

20. If user has both pending invitations AND creates their own workspace (via "Skapa eget workspace istället"), the invitations remain in PENDING state — they can be accepted later from workspace settings (out of scope for this story)
21. Multiple invitations to the same workspace are deduplicated — only show the most recent one

## Tasks / Subtasks

- [ ] **Task 1: Add WorkspaceInvitation model to Prisma schema** (AC: 1, 2, 3)
  - [ ] Add `InvitationStatus` enum to `prisma/schema.prisma`:
    ```prisma
    enum InvitationStatus {
      PENDING
      ACCEPTED
      EXPIRED
      REVOKED
    }
    ```
  - [ ] Add `WorkspaceInvitation` model:

    ```prisma
    model WorkspaceInvitation {
      id           String           @id @default(uuid())
      workspace_id String
      email        String
      role         WorkspaceRole    @default(MEMBER)
      token        String           @unique
      invited_by   String
      status       InvitationStatus @default(PENDING)
      expires_at   DateTime
      created_at   DateTime         @default(now())

      workspace Workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
      inviter   User      @relation("InvitationInviter", fields: [invited_by], references: [id])

      @@index([email])
      @@index([workspace_id])
      @@index([token])
      @@map("workspace_invitations")
    }
    ```

  - [ ] Add `invitations WorkspaceInvitation[]` relation to `Workspace` model
  - [ ] Add `sent_invitations WorkspaceInvitation[] @relation("InvitationInviter")` relation to `User` model
  - [ ] Run `pnpm prisma migrate dev --name add_workspace_invitations` to create migration

- [ ] **Task 2: Create invitation server actions** (AC: 4, 5, 6, 12, 13, 14, 15, 17)
  - [ ] Create `app/actions/invitations.ts` with the following functions:
  - [ ] `getPendingInvitations(email: string)` — queries `WorkspaceInvitation` where `email` matches, `status = PENDING`, `expires_at > now()`. Marks any expired invitations as `EXPIRED`. Returns invitations with workspace name and inviter name via Prisma `include`.
  - [ ] `acceptInvitation(invitationId: string)` — validates invitation exists, is PENDING, not expired. Creates `WorkspaceMember` with specified role. Updates invitation status to `ACCEPTED`. Sets active workspace cookie. Invalidates user cache. Returns `{ success: true, workspaceId }`.
  - [ ] `declineInvitation(invitationId: string)` — validates invitation exists, is PENDING. Updates status to `REVOKED`. Returns `{ success: true }`.
  - [ ] `generateInvitationToken()` — generates 32-byte cryptographically random token using `crypto.randomBytes(32).toString('base64url')`. This utility is for future use by Story 5.3 (sending invitations).
  - [ ] All actions check authentication via `getServerSession()` and verify the email matches the session user

- [ ] **Task 3: Build pending invitations UI** (AC: 7, 8, 9, 10, 11)
  - [ ] Create `app/onboarding/_components/pending-invitations.tsx` — `'use client'` component
  - [ ] Props: `invitations: InvitationWithDetails[]`, `onAllDeclined: () => void`, `redirectUrl?: string`
  - [ ] Render each invitation as a shadcn/ui `Card` with:
    - Workspace name as heading
    - Role in Swedish: map `OWNER` → "Ägare", `ADMIN` → "Administratör", `HR_MANAGER` → "HR-ansvarig", `MEMBER` → "Medlem", `AUDITOR` → "Revisor"
    - Inviter name: "Inbjuden av: {name}"
    - Expiry: "Gäller till: {date}"
  - [ ] "Acceptera" button (primary/default variant) calls `acceptInvitation()` action
  - [ ] "Avböj" button (outline variant) calls `declineInvitation()` action
  - [ ] Loading states on both buttons during action execution
  - [ ] Below cards: `<Link>` styled as text link: "Skapa eget workspace istället" — calls `onAllDeclined()` to switch to wizard view
  - [ ] After accepting: `router.push(redirectUrl || '/dashboard')`
  - [ ] After declining last invitation: call `onAllDeclined()`
  - [ ] After declining with more remaining: remove the declined card from the list (optimistic update or refetch)

- [ ] **Task 4: Integrate invitation check into onboarding page** (AC: 5, 7, 21)
  - [ ] In `app/onboarding/page.tsx` (Server Component), call `getCurrentUser()` from `@/lib/auth/session` to obtain the user's email (user is guaranteed authenticated by `layout.tsx` guard)
  - [ ] Call `getPendingInvitations(user.email)` from `@/app/actions/invitations` to check for pending invitations
  - [ ] Deduplicate: if multiple invitations to the same workspace exist, only pass the most recent one to the UI
  - [ ] Pass invitations as a prop to the `OnboardingWizard` component alongside existing `redirect` and `state` props
  - [ ] In `onboarding-wizard.tsx`, accept an `invitations` prop (typed as the invitation array or empty array). If invitations are present, show `PendingInvitations` component instead of the wizard steps. If user dismisses all (declines all or clicks "Skapa eget workspace"), switch to the wizard steps via local state toggle.

- [ ] **Task 5: Handle edge cases** (AC: 6, 20, 21)
  - [ ] In `getPendingInvitations()`, bulk-update expired invitations: `updateMany({ where: { email, status: 'PENDING', expires_at: { lt: new Date() } }, data: { status: 'EXPIRED' } })`
  - [ ] If user creates their own workspace after dismissing invitations, invitations remain in PENDING state — no action needed (they expire naturally after 7 days)
  - [ ] Deduplication logic: group by `workspace_id`, take the one with latest `created_at`

- [ ] **Task 6: Regression testing** (AC: all)
  - [ ] Test: user with no invitations → wizard shows directly
  - [ ] Test: user with 1 pending invitation → invitation card shown → accept → joined workspace → dashboard
  - [ ] Test: user with 1 pending invitation → decline → wizard shown
  - [ ] Test: user with 2 invitations → decline first → second shown → accept second → dashboard
  - [ ] Test: user with expired invitation → not shown, wizard shown
  - [ ] Test: user clicks "Skapa eget workspace istället" → wizard shown, invitations still PENDING
  - [ ] Test: existing workspace creation flow (Stories 10.1 + 10.2) still works

## Dev Notes

### Previous Story Insights

**From Story 10.2 (Workspace Creation Wizard) — Done:**

- The onboarding `page.tsx` is a Server Component that reads `searchParams: Promise<{ redirect?: string; state?: string }>` and passes them as props to the client wizard component. For this story, `page.tsx` must ALSO call `getCurrentUser()` to obtain the user's email, then query pending invitations server-side before passing them to the wizard.
- The wizard container uses `WIZARD_STEPS` array with `step.id` matching for rendering. The pattern uses an IIFE with `stepId = WIZARD_STEPS[currentStep]?.id` and optional chaining for `noUncheckedIndexedAccess` compliance.
- `getSafeRedirectUrl()` from `@/lib/utils` is used for redirect URL validation (reuse, do not redefine).
- `Toaster` from `@/components/ui/sonner` is already mounted in `page.tsx` — no need to add it again.
- The layout uses `max-w-md` container width (layout line 45). Invitation card UI must fit within this constraint.
- `invalidateUserCache(userId, ['context'])` is the correct invocation signature — imported from `@/lib/cache/workspace-cache` (NOT from `workspace-context.ts`).
- `setActiveWorkspace(workspaceId)` is imported from `@/lib/auth/workspace-context`.
- `exactOptionalPropertyTypes: true` requires `| undefined` on optional interface props.
- `noUncheckedIndexedAccess: true` requires optional chaining on array index access.
- 20 pre-existing failing tests (redis, caching, auth signup) — zero new failures expected.

### Architecture Sources

- **Server Actions**: `app/actions/` pattern — async functions with `'use server'`, return `{ success, error }` [Source: architecture/17-coding-standards.md#17.5]
- **Database**: Prisma transactions, unique constraints, enum types [Source: architecture/17-coding-standards.md#17.4]
- **Auth**: `getServerSession()` from `lib/auth/session.ts` for auth checks in actions [Source: architecture/17-coding-standards.md#17.6]
- **Caching**: `invalidateUserCache(userId, ['context'])` from `@/lib/cache/workspace-cache`; `setActiveWorkspace(workspaceId)` from `@/lib/auth/workspace-context` [Source: app/actions/workspace.ts:17-21]
- **Component Standards**: shadcn/ui Card, Button, Link [Source: architecture/17-coding-standards.md#17.3]
- **Data Model**: `WorkspaceInvitation` with 7-day expiry, token-based lookup [Source: architecture/4-data-models.md#4.19]

### Relevant Source Tree

```
prisma/
  schema.prisma                       # MODIFY: Add InvitationStatus enum + WorkspaceInvitation model
    - Line 57-101: Workspace model — add 'invitations' relation
    - Line 20-55: User model — add 'sent_invitations' relation
    - Line 103-123: WorkspaceMember model — REFERENCE for role types
  migrations/                         # NEW: Migration for workspace_invitations table

app/actions/
  invitations.ts                      # NEW: getPendingInvitations(), acceptInvitation(), declineInvitation()
  workspace.ts                        # REFERENCE: Pattern for server actions, cache invalidation
    - Lines 1-21: Import pattern — getServerSession, setActiveWorkspace, invalidateUserCache, invalidateWorkspaceCache
    - Line 273-319: addWorkspaceMember() — REFERENCE for creating WorkspaceMember records
    - Line 56-214: createWorkspace() — REFERENCE for Prisma transaction + cache invalidation pattern

app/onboarding/
  page.tsx                            # MODIFY: Add invitation check before rendering wizard
  _components/
    onboarding-wizard.tsx             # MODIFY: Accept invitations prop, show PendingInvitations if present
    pending-invitations.tsx           # NEW: 'use client' invitation cards with accept/decline

lib/auth/
  workspace-context.ts                # READ ONLY: setActiveWorkspace()
    - Line 286-293: setActiveWorkspace(workspaceId) — sets httpOnly cookie for active workspace
  session.ts                          # READ ONLY: getServerSession(), getCurrentUser()
    - Line 8-9: getServerSession() — wrapper for NextAuth session
    - Line 16-19: getCurrentUser() — returns session?.user || null

lib/cache/
  workspace-cache.ts                  # READ ONLY: Cache invalidation utilities
    - invalidateUserCache(userId, ['context']) — clears user workspace context cache in Redis
    - invalidateWorkspaceCache(workspaceId, [...]) — clears workspace-specific caches
```

### Key Implementation Details

1. **Invitation token generation.** Use Node.js `crypto` module:

   ```typescript
   import { randomBytes } from 'crypto'
   export function generateInvitationToken(): string {
     return randomBytes(32).toString('base64url')
   }
   ```

   The token is for future use (Story 5.3 will use it in invite email links). For now, just store it on creation.

2. **This story creates the model and acceptance flow only.** The _sending_ of invitations (from workspace settings UI, with email delivery) is covered by Story 5.3. Story 5.3 should be updated to depend on this model rather than creating its own. For testing this story, you'll need to manually insert invitation records in the database.

3. **Role mapping for Swedish UI:**

   ```typescript
   const ROLE_LABELS: Record<WorkspaceRole, string> = {
     OWNER: 'Ägare',
     ADMIN: 'Administratör',
     HR_MANAGER: 'HR-ansvarig',
     MEMBER: 'Medlem',
     AUDITOR: 'Revisor',
   }
   ```

4. **acceptInvitation security checks:**
   - Verify the authenticated user's email matches the invitation email
   - Verify invitation status is PENDING
   - Verify `expires_at > now()`
   - Verify the workspace still exists and is ACTIVE
   - Check that user isn't already a member of that workspace

5. **Prisma include for invitation details:**

   ```typescript
   const invitations = await prisma.workspaceInvitation.findMany({
     where: {
       email: userEmail,
       status: 'PENDING',
       expires_at: { gt: new Date() },
     },
     include: {
       workspace: { select: { id: true, name: true, status: true } },
       inviter: { select: { id: true, name: true, email: true } },
     },
     orderBy: { created_at: 'desc' },
   })
   ```

6. **Relationship to existing invitation fields.** `WorkspaceMember` already has `invited_by` and `invited_at` fields. When accepting an invitation, populate these on the new `WorkspaceMember` record:
   ```typescript
   await tx.workspaceMember.create({
     data: {
       user_id: userId,
       workspace_id: invitation.workspace_id,
       role: invitation.role,
       invited_by: invitation.invited_by,
       invited_at: invitation.created_at,
     },
   })
   ```

### Coding Standards

- Server actions in `app/actions/` with `'use server'` directive [Source: architecture/17-coding-standards.md#17.5]
- Prisma migration naming: `add_workspace_invitations` [Source: architecture/17-coding-standards.md#17.4]
- TypeScript strict mode — explicit types for all function parameters and returns [Source: architecture/17-coding-standards.md#17.2]
- shadcn/ui components for all UI elements [Source: architecture/17-coding-standards.md#17.3]
- Import path aliases: `@/app/actions/invitations`, `@/lib/auth/session` [Source: architecture/12-unified-project-structure.md#12.5]
- Workspace-scoped queries — always filter by workspace_id where applicable [Source: architecture/17-coding-standards.md#17.4]

### Testing

- **Test approach**: Manual testing with seed data. Insert invitation records directly in database for testing since invitation sending (Story 5.3) isn't built yet.
- **Seed data setup** (for manual testing):
  ```sql
  INSERT INTO workspace_invitations (id, workspace_id, email, role, token, invited_by, status, expires_at, created_at)
  VALUES (
    gen_random_uuid(),
    '<existing-workspace-id>',
    '<test-user-email>',
    'MEMBER',
    'test-token-abc123',
    '<inviter-user-id>',
    'PENDING',
    NOW() + INTERVAL '7 days',
    NOW()
  );
  ```
- **Critical flows**:
  1. User with pending invitation → shown at onboarding → accept → joined → dashboard
  2. User with pending invitation → decline → wizard shown
  3. User with expired invitation → not shown
  4. Accept invitation → WorkspaceMember created with correct role, invited_by, invited_at
  5. Accept invitation → active workspace cookie set, cache invalidated
  6. User already member of workspace → handle gracefully (show message or skip)
- **Test file location**: `tests/integration/actions/invitations.test.ts`
- **Testing framework**: Vitest for unit tests, manual testing for full flow [Source: architecture/17-coding-standards.md]

## Change Log

| Date       | Version | Description                                                                                                                                                                                          | Author     |
| ---------- | ------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| 2026-01-30 | 1.0     | Initial story creation                                                                                                                                                                               | Sarah (PO) |
| 2026-01-31 | 1.1     | SM review: Fixed addWorkspaceMember line ref (191→273), fixed invalidateUserCache source (workspace-context→cache/workspace-cache), added Previous Story Insights, clarified Task 4 getCurrentUser() | Bob (SM)   |

## Dev Agent Record

### Agent Model Used

_To be filled by development agent_

### Debug Log References

_To be filled by development agent_

### Completion Notes List

_To be filled by development agent_

### File List

_To be filled by development agent_

## QA Results

_To be filled by QA agent_
