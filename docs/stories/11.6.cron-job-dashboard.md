# Story 11.6: Cron Job Dashboard & Manual Triggers

## Status

Draft

## Story

**As an** admin,
**I want** to see the status of all cron jobs and trigger them manually,
**so that** I can monitor data freshness and recover from failures.

## Acceptance Criteria

1. Cron job page at `/admin/cron-jobs`
2. Job registry: a hardcoded configuration listing all known cron jobs with name, description, schedule, and API endpoint
3. For each job, display:
   - Job name and description
   - Schedule (human-readable, e.g. "Dagligen kl. 03:00 UTC")
   - Last run: timestamp, duration, status (success/failed/running)
   - Items processed / items failed (from last run)
4. Status indicators: green (last run succeeded), red (last run failed), yellow (running now), grey (never run)
5. "Kör nu" (Run now) button per job with confirmation dialog
6. Manual trigger calls the job's API endpoint server-side (via internal `fetch()`) with proper auth headers (`CRON_SECRET`)
7. Running state shown while job executes (polling every 5s to check if `CronJobRun` status changed from RUNNING)
8. Health checks displayed:
   - Riksdagen API reachable (yes/no)
   - Domstolsverket API reachable (yes/no)
   - Database connection OK
   - Redis connection OK
9. New `CronJobRun` Prisma model to persist job execution history
10. Cron job endpoints updated to create a `CronJobRun` record at start and update it on completion/failure

## Tasks / Subtasks

- [ ] **Task 1: Add CronJobRun model to Prisma** (AC: 9)
  - [ ] Add to `prisma/schema.prisma`:

    ```prisma
    model CronJobRun {
      id              String       @id @default(uuid())
      job_name        String
      status          JobRunStatus @default(RUNNING)
      started_at      DateTime     @default(now())
      completed_at    DateTime?
      duration_ms     Int?
      items_processed Int          @default(0)
      items_failed    Int          @default(0)
      error_message   String?
      error_stack     String?      @db.Text
      log_output      String?      @db.Text
      triggered_by    String?      // "cron" or admin email
      metadata        Json?

      @@index([job_name, started_at(sort: Desc)])
      @@map("cron_job_runs")
    }

    enum JobRunStatus {
      RUNNING
      SUCCESS
      FAILED
    }
    ```

  - [ ] Add `invitations` relation name is already taken — ensure no conflicts with existing models
  - [ ] Run `pnpm prisma migrate dev --name add_cron_job_runs`
  - [ ] Generate Prisma client

- [ ] **Task 2: Create job logger utility** (AC: 10)
  - [ ] Create `lib/admin/job-logger.ts`:
  - [ ] `startJobRun(jobName: string, triggeredBy?: string): Promise<string>` — creates a `CronJobRun` record with `status: RUNNING`, returns the run ID
  - [ ] `completeJobRun(runId: string, result: { itemsProcessed: number, itemsFailed: number, metadata?: Record<string, unknown> }): Promise<void>` — updates the run with `status: SUCCESS`, `completed_at: now()`, `duration_ms`, results
  - [ ] `failJobRun(runId: string, error: Error): Promise<void>` — updates with `status: FAILED`, `error_message`, `error_stack`, `completed_at: now()`, `duration_ms`
  - [ ] `appendJobLog(runId: string, message: string): Promise<void>` — appends to `log_output` field (for structured logging during execution)
  - [ ] All functions wrapped in try/catch — logging failures must NOT crash the actual cron job

- [ ] **Task 3: Integrate job logging into existing cron endpoints** (AC: 10)
  - [ ] Modify `app/api/cron/warm-cache/route.ts`:
    - Import `startJobRun`, `completeJobRun`, `failJobRun` from `@/lib/admin/job-logger`
    - At start: `const runId = await startJobRun('warm-cache', triggeredBy)`
    - Use `appendJobLog(runId, ...)` for progress messages instead of `console.log`
    - On success: `await completeJobRun(runId, { itemsProcessed, itemsFailed })`
    - On error: `await failJobRun(runId, error)`
    - Determine `triggeredBy`: check for `x-triggered-by` custom header (set by admin trigger), default to `'cron'`
  - [ ] Modify `app/api/cron/prewarm-cache/route.ts` — same pattern

- [ ] **Task 4: Create job registry** (AC: 2)
  - [ ] Create `lib/admin/job-registry.ts`:

    ```typescript
    export interface CronJobDefinition {
      name: string
      displayName: string
      description: string
      schedule: string // Cron expression
      scheduleHuman: string // Human-readable, Swedish
      endpoint: string // API route path
      authHeader: string // Env var name for auth token
    }

    export const JOB_REGISTRY: CronJobDefinition[] = [
      {
        name: 'warm-cache',
        displayName: 'Cache Warming',
        description:
          'Värmer cache för populära dokument baserat på laglistor och besök',
        schedule: '0 */4 * * *',
        scheduleHuman: 'Var 4:e timme',
        endpoint: '/api/cron/warm-cache',
        authHeader: 'CRON_SECRET',
      },
      {
        name: 'prewarm-cache',
        displayName: 'Cache Pre-warming',
        description: 'Förladdar cache vid uppstart',
        schedule: 'On deploy',
        scheduleHuman: 'Vid deploy',
        endpoint: '/api/cron/prewarm-cache',
        authHeader: 'CRON_SECRET',
      },
      // Future jobs (SFS sync, court sync, EU sync) will be added here
    ]
    ```

- [ ] **Task 5: Create health check utilities** (AC: 8)
  - [ ] Create `lib/admin/health.ts`:
  - [ ] `checkRiksdagenApi(): Promise<{ ok: boolean; latencyMs: number }>` — `fetch('https://data.riksdagen.se/dokumentlista/?sok=test&utformat=json&antal=1')` with 5s timeout
  - [ ] `checkDomstolsverketApi(): Promise<{ ok: boolean; latencyMs: number }>` — ping the court API endpoint with 5s timeout
  - [ ] `checkDatabase(): Promise<{ ok: boolean; latencyMs: number }>` — `prisma.$queryRaw(SELECT 1)` with timing
  - [ ] `checkRedis(): Promise<{ ok: boolean; latencyMs: number }>` — `redis.ping()` with timing
  - [ ] `runAllHealthChecks(): Promise<HealthCheckResult[]>` — runs all checks in parallel via `Promise.allSettled()`

- [ ] **Task 6: Create cron job queries** (AC: 3, 4)
  - [ ] Add to `lib/admin/queries.ts`:
  - [ ] `getLatestJobRuns(jobNames: string[]): Promise<Record<string, CronJobRun | null>>` — for each job name, get the most recent `CronJobRun` record
  - [ ] `getRunningJobs(): Promise<CronJobRun[]>` — find all runs with `status: RUNNING`

- [ ] **Task 7: Create cron job trigger action** (AC: 5, 6)
  - [ ] Create `app/actions/admin-cron.ts` with `'use server'` directive
  - [ ] `triggerJob(jobName: string)`:
    - Verify admin session via `getAdminSession()`
    - Look up job in `JOB_REGISTRY` by name — reject if not found
    - Call the job endpoint via internal `fetch()`:
      ```typescript
      const url = `${process.env.NEXTAUTH_URL}${job.endpoint}`
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          Authorization: `Bearer ${process.env[job.authHeader]}`,
          'x-triggered-by': adminEmail,
        },
      })
      ```
    - Return `{ success: true }` (the job runs asynchronously; polling will pick up the status)

- [ ] **Task 8: Create cron job dashboard page** (AC: 1, 2, 3, 4, 5, 6, 7, 8)
  - [ ] Create `app/admin/(dashboard)/cron-jobs/page.tsx` — Server Component
  - [ ] Fetch job registry + latest runs + health checks in parallel
  - [ ] Render job cards (one per registered job):
    - Job name, description, schedule
    - Last run info with status indicator (colored dot)
    - "Kör nu" button
  - [ ] Render health check section as a grid of status indicators
  - [ ] Create `'use client'` component for job card with trigger functionality:
    - `components/admin/cron-job-card.tsx`
    - "Kör nu" button → `AlertDialog` confirmation → call `triggerJob()` action
    - While running: show spinner, poll every 5s via `setInterval` + `fetch` to a lightweight API endpoint or refetch via `router.refresh()`
  - [ ] Link each job card to `/admin/cron-jobs/[jobName]` for detailed logs (Story 11.7)

- [ ] **Task 9: Testing** (AC: all)
  - **Automated (Vitest)** — write in `tests/unit/lib/admin/job-logger.test.ts`:
  - [ ] Test: `startJobRun()` creates a CronJobRun with RUNNING status
  - [ ] Test: `completeJobRun()` updates status to SUCCESS with duration
  - [ ] Test: `failJobRun()` updates status to FAILED with error details
  - [ ] Test: `appendJobLog()` appends to log_output
  - [ ] Test: job logger functions don't throw on DB errors (graceful degradation)
  - Write in `tests/unit/lib/admin/health.test.ts`:
  - [ ] Test: `checkDatabase()` returns ok:true when DB is accessible
  - [ ] Test: `checkRedis()` returns ok:true when Redis is accessible
  - [ ] Test: `runAllHealthChecks()` handles partial failures gracefully
  - **Manual:**
  - [ ] Test: dashboard shows all registered jobs with last run info
  - [ ] Test: trigger a job manually → status changes to RUNNING → completes
  - [ ] Test: health checks display correctly
  - [ ] Test: existing cron jobs still work and now log runs

## Dev Notes

### Dependencies

- **Blocked by:** Story 11.1 (Admin Auth & Shell Layout) — requires admin auth
- **Independent of:** Stories 11.2, 11.3, 11.4, 11.5
- **Blocks:** Story 11.7 (Job Execution Logs) — depends on CronJobRun model and data

### Architecture Context

This story introduces a schema migration (`CronJobRun`) and modifies existing cron endpoints. The modifications are additive — if job logging fails, the cron job itself continues to work normally.

**Key design decision:** The job logger is "fire and forget" — all logging operations are wrapped in try/catch. A failed log write must NEVER cause the actual cron job to fail. This ensures backward compatibility.

### Relevant Source Tree

```
prisma/
  schema.prisma                       # MODIFY: Add CronJobRun model, JobRunStatus enum
  migrations/                         # NEW: Migration for cron_job_runs table

lib/admin/
  job-logger.ts                       # NEW: Job run logging utilities
  job-registry.ts                     # NEW: Static registry of cron jobs
  health.ts                           # NEW: Health check utilities
  queries.ts                          # EXTEND: Add getLatestJobRuns(), getRunningJobs()

app/actions/
  admin-cron.ts                       # NEW: triggerJob() server action

app/admin/(dashboard)/
  cron-jobs/
    page.tsx                          # NEW: Cron job dashboard

components/admin/
  cron-job-card.tsx                   # NEW: 'use client' job card with trigger

# MODIFIED EXISTING FILES:
app/api/cron/warm-cache/route.ts      # MODIFY: Add job logging (lines 37-141)
  - Line 20-28: Auth check — keep unchanged
  - Line 37: try block start — add startJobRun() call
  - Line 101: success response — add completeJobRun() call
  - Line 132-141: error handler — add failJobRun() call
app/api/cron/prewarm-cache/route.ts   # MODIFY: Add job logging (same pattern)

# REFERENCE FILES:
lib/cache/redis.ts                    # Redis client — for health check
lib/prisma.ts                         # Prisma client — for health check
lib/api/riksdagen.ts                  # Riksdagen API base URL — for health check
```

### Key Implementation Details

1. **Job logger wrapping pattern.** The cron endpoint modifications should follow this pattern:

   ```typescript
   export async function GET(request: NextRequest) {
     // Existing auth check (unchanged)
     const authHeader = request.headers.get('authorization')
     // ...

     const triggeredBy = request.headers.get('x-triggered-by') || 'cron'
     let runId: string | undefined

     try {
       runId = await startJobRun('warm-cache', triggeredBy)
     } catch {
       // Log failure but continue — don't block the job
       console.error('Failed to start job run logging')
     }

     try {
       // ... existing job logic ...

       if (runId) {
         await completeJobRun(runId, { itemsProcessed: newlyCached, itemsFailed: failed })
       }

       return NextResponse.json({ success: true, ... })
     } catch (error) {
       if (runId) {
         await failJobRun(runId, error instanceof Error ? error : new Error(String(error)))
       }
       // ... existing error handling ...
     }
   }
   ```

2. **Health check timeout.** Use `AbortController` for fetch timeouts:

   ```typescript
   async function fetchWithTimeout(url: string, timeoutMs: number) {
     const controller = new AbortController()
     const timeout = setTimeout(() => controller.abort(), timeoutMs)
     try {
       const response = await fetch(url, { signal: controller.signal })
       return response
     } finally {
       clearTimeout(timeout)
     }
   }
   ```

3. **Polling for running status.** The simplest approach is `router.refresh()` on an interval, which re-runs the Server Component data fetch. No need for a separate API endpoint:

   ```typescript
   // In cron-job-card.tsx (client component)
   useEffect(() => {
     if (!isRunning) return
     const interval = setInterval(() => {
       router.refresh()
     }, 5000)
     return () => clearInterval(interval)
   }, [isRunning, router])
   ```

4. **`log_output` appending.** Use Prisma's raw SQL for efficient append:

   ```typescript
   export async function appendJobLog(runId: string, message: string) {
     const timestamp = new Date().toISOString()
     const line = `[${timestamp}] ${message}\n`
     await prisma.$executeRaw`
       UPDATE cron_job_runs
       SET log_output = COALESCE(log_output, '') || ${line}
       WHERE id = ${runId}
     `
   }
   ```

5. **Riksdagen API health check URL.** Based on existing API client, use: `https://data.riksdagen.se/dokumentlista/?sok=test&utformat=json&antal=1`

6. **Future extensibility.** When new sync jobs are created (SFS sync, court sync, EU sync), they just need to:
   - Add an entry to `JOB_REGISTRY`
   - Call `startJobRun()` / `completeJobRun()` / `failJobRun()` in their endpoint

### Coding Standards

- Prisma migration naming: `add_cron_job_runs` [Source: architecture/17-coding-standards.md#17.4]
- Server actions with `'use server'` directive [Source: architecture/17-coding-standards.md#17.5]
- shadcn/ui components: Card, AlertDialog, Badge, Button [Source: architecture/17-coding-standards.md#17.3]
- Graceful error handling — logging failures never crash the main job [Source: architecture/17-coding-standards.md#17.5]
- `force-dynamic` for admin pages [Source: admin pages should never be cached]

### Testing

- **Test file locations**: `tests/unit/lib/admin/job-logger.test.ts`, `tests/unit/lib/admin/health.test.ts`
- **Testing framework**: Vitest [Source: architecture/17-coding-standards.md]
- **Mock strategy**: Mock `prisma` for job logger tests, mock `fetch` and `redis` for health check tests
- **Critical manual tests**: Trigger job → verify CronJobRun created → verify completion/failure logged, existing cron jobs still function correctly

## Change Log

| Date       | Version | Description            | Author     |
| ---------- | ------- | ---------------------- | ---------- |
| 2026-02-02 | 1.0     | Initial story creation | Sarah (PO) |
