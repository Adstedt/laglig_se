# Story 5.6: Build Add-On Purchase System

## Status
Draft

## Story

**As a** user,
**I want** to purchase add-ons instead of upgrading my entire tier,
**so that** I can grow incrementally.

## Acceptance Criteria

1. Add-ons defined:
   - +10 employees: â‚¬100/month
   - +5GB storage: â‚¬50/month
2. Billing page shows "Add-ons" section
3. User can toggle add-ons on/off
4. Clicking "Add +10 employees" â†’ Stripe creates additional subscription item
5. Add-on pricing prorated (charged immediately for current billing period)
6. Add-ons included in usage limit calculations
7. Example: Team tier (50 employees) + 2x add-ons = 70 employee limit
8. Stripe webhook updates add-on status
9. Invoice line items show base tier + add-ons separately

## Tasks / Subtasks

- [ ] Create Stripe Products for add-ons
- [ ] Build add-ons UI section on billing page
- [ ] Implement add-on purchase API
- [ ] Update usage limit calculations to include add-ons
- [ ] Handle proration in Stripe
- [ ] Sync add-on status via webhooks
- [ ] Display add-ons on invoices
- [ ] Test add-on purchase and removal

## Dev Notes

**Add-On Definitions:**
```typescript
// lib/addons/config.ts

export interface AddOn {
  id: string
  name: string
  description: string
  priceMonthly: number
  stripePriceId: string
  benefit: {
    type: 'employees' | 'storage'
    amount: number
  }
}

export const AVAILABLE_ADDONS: AddOn[] = [
  {
    id: 'employees_10',
    name: '+10 Employees',
    description: 'Add capacity for 10 more employees',
    priceMonthly: 100,
    stripePriceId: process.env.STRIPE_ADDON_EMPLOYEES_PRICE_ID!,
    benefit: {
      type: 'employees',
      amount: 10
    }
  },
  {
    id: 'storage_5gb',
    name: '+5GB Storage',
    description: 'Add 5GB of additional storage',
    priceMonthly: 50,
    stripePriceId: process.env.STRIPE_ADDON_STORAGE_PRICE_ID!,
    benefit: {
      type: 'storage',
      amount: 5
    }
  }
]

export function getAddOnById(id: string): AddOn | undefined {
  return AVAILABLE_ADDONS.find((addon) => addon.id === id)
}
```

**Database Schema:**
```prisma
model WorkspaceAddOn {
  id              String   @id @default(uuid())
  workspaceId     String
  addOnId         String   // employees_10, storage_5gb
  quantity        Int      @default(1)
  stripeItemId    String?  // Stripe subscription item ID
  activatedAt     DateTime @default(now())
  deactivatedAt   DateTime?

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@index([workspaceId, addOnId])
  @@map("workspace_addons")
}
```

**Add-Ons UI Component:**
```typescript
// components/billing/addons-section.tsx
'use client'

import { useState, useEffect } from 'react'
import { AVAILABLE_ADDONS } from '@/lib/addons/config'

export function AddOnsSection() {
  const [activeAddOns, setActiveAddOns] = useState<any[]>([])
  const [isLoading, setIsLoading] = useState(false)

  useEffect(() => {
    async function fetchAddOns() {
      const response = await fetch('/api/billing/addons')
      const data = await response.json()
      setActiveAddOns(data.addons)
    }

    fetchAddOns()
  }, [])

  async function toggleAddOn(addOnId: string, currentQuantity: number) {
    setIsLoading(true)

    try {
      if (currentQuantity > 0) {
        // Remove add-on
        await fetch(`/api/billing/addons/${addOnId}`, {
          method: 'DELETE'
        })
      } else {
        // Add add-on
        await fetch('/api/billing/addons', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ addOnId, quantity: 1 })
        })
      }

      // Refresh
      const response = await fetch('/api/billing/addons')
      const data = await response.json()
      setActiveAddOns(data.addons)
    } catch (error) {
      alert('Failed to update add-on')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h2 className="text-lg font-semibold mb-4">Add-Ons</h2>
      <p className="text-sm text-gray-600 mb-6">
        Enhance your plan with additional capacity without upgrading your entire tier.
      </p>

      <div className="space-y-4">
        {AVAILABLE_ADDONS.map((addon) => {
          const active = activeAddOns.find((a) => a.addOnId === addon.id)
          const quantity = active?.quantity || 0

          return (
            <div
              key={addon.id}
              className="flex items-center justify-between p-4 border rounded-lg"
            >
              <div className="flex-1">
                <div className="flex items-center gap-2 mb-1">
                  <h3 className="font-semibold">{addon.name}</h3>
                  {quantity > 0 && (
                    <span className="px-2 py-0.5 text-xs bg-green-100 text-green-700 rounded">
                      Active (Ã—{quantity})
                    </span>
                  )}
                </div>
                <p className="text-sm text-gray-600">{addon.description}</p>
                <p className="text-sm font-medium text-gray-900 mt-2">
                  â‚¬{addon.priceMonthly}/month
                </p>
              </div>

              <div className="flex items-center gap-3">
                {quantity > 0 && (
                  <div className="flex items-center gap-2">
                    <button
                      onClick={() => changeQuantity(addon.id, quantity - 1)}
                      disabled={isLoading}
                      className="w-8 h-8 border rounded hover:bg-gray-50 disabled:opacity-50"
                    >
                      âˆ’
                    </button>
                    <span className="w-8 text-center font-medium">{quantity}</span>
                    <button
                      onClick={() => changeQuantity(addon.id, quantity + 1)}
                      disabled={isLoading}
                      className="w-8 h-8 border rounded hover:bg-gray-50 disabled:opacity-50"
                    >
                      +
                    </button>
                  </div>
                )}

                <button
                  onClick={() => toggleAddOn(addon.id, quantity)}
                  disabled={isLoading}
                  className={`px-4 py-2 rounded-lg font-medium ${
                    quantity > 0
                      ? 'border border-gray-300 hover:bg-gray-50'
                      : 'bg-blue-600 text-white hover:bg-blue-700'
                  } disabled:opacity-50`}
                >
                  {quantity > 0 ? 'Remove' : 'Add'}
                </button>
              </div>
            </div>
          )
        })}
      </div>

      <div className="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
        <p className="text-sm text-blue-900">
          ðŸ’¡ Add-ons are prorated and will be charged immediately for the current
          billing period.
        </p>
      </div>
    </div>
  )
}
```

**Add-On Purchase API:**
```typescript
// app/api/billing/addons/route.ts
export async function GET(request: Request) {
  return withWorkspace(async ({ workspaceId }) => {
    const addons = await prisma.workspaceAddOn.findMany({
      where: {
        workspaceId,
        deactivatedAt: null
      }
    })

    return NextResponse.json({ addons })
  })
}

export async function POST(request: Request) {
  return withWorkspace(async ({ workspaceId, workspace, role }) => {
    checkPermission(role as WorkspaceRole, Permission.MANAGE_BILLING)

    const { addOnId, quantity } = await request.json()

    const addon = getAddOnById(addOnId)
    if (!addon) {
      return NextResponse.json({ error: 'Invalid add-on' }, { status: 400 })
    }

    // Get Stripe subscription
    if (!workspace.stripeSubscriptionId) {
      return NextResponse.json(
        { error: 'No active subscription' },
        { status: 400 }
      )
    }

    const subscription = await stripe.subscriptions.retrieve(
      workspace.stripeSubscriptionId
    )

    // Add subscription item for add-on
    const subscriptionItem = await stripe.subscriptionItems.create({
      subscription: workspace.stripeSubscriptionId,
      price: addon.stripePriceId,
      quantity,
      proration_behavior: 'always_invoice' // Prorate and charge immediately
    })

    // Store in database
    await prisma.workspaceAddOn.create({
      data: {
        workspaceId,
        addOnId,
        quantity,
        stripeItemId: subscriptionItem.id
      }
    })

    return NextResponse.json({ success: true })
  })
}
```

**Remove Add-On API:**
```typescript
// app/api/billing/addons/[addOnId]/route.ts
export async function DELETE(
  request: Request,
  { params }: { params: { addOnId: string } }
) {
  return withWorkspace(async ({ workspaceId, role }) => {
    checkPermission(role as WorkspaceRole, Permission.MANAGE_BILLING)

    const addon = await prisma.workspaceAddOn.findFirst({
      where: {
        workspaceId,
        addOnId: params.addOnId,
        deactivatedAt: null
      }
    })

    if (!addon) {
      return NextResponse.json({ error: 'Add-on not found' }, { status: 404 })
    }

    // Remove from Stripe
    if (addon.stripeItemId) {
      await stripe.subscriptionItems.del(addon.stripeItemId, {
        proration_behavior: 'always_invoice'
      })
    }

    // Mark as deactivated
    await prisma.workspaceAddOn.update({
      where: { id: addon.id },
      data: { deactivatedAt: new Date() }
    })

    return NextResponse.json({ success: true })
  })
}
```

**Updated Usage Limits with Add-Ons:**
```typescript
// lib/usage/limits.ts (updated)

export async function getEffectiveLimits(workspaceId: string): Promise<UsageLimits> {
  const workspace = await prisma.workspace.findUnique({
    where: { id: workspaceId },
    include: {
      addons: {
        where: { deactivatedAt: null }
      }
    }
  })

  if (!workspace) {
    throw new Error('Workspace not found')
  }

  const baseLimits = getLimits(workspace.subscriptionTier)

  // Add benefits from add-ons
  let effectiveLimits = { ...baseLimits }

  for (const addon of workspace.addons) {
    const addOnConfig = getAddOnById(addon.addOnId)
    if (!addOnConfig) continue

    const benefit = addOnConfig.benefit
    const totalBenefit = benefit.amount * addon.quantity

    if (benefit.type === 'employees') {
      if (effectiveLimits.employees !== null) {
        effectiveLimits.employees += totalBenefit
      }
    } else if (benefit.type === 'storage') {
      if (effectiveLimits.storageGB !== null) {
        effectiveLimits.storageGB += totalBenefit
      }
    }
  }

  return effectiveLimits
}

// Update usage check to use effective limits
export async function checkUsageLimit(
  workspaceId: string,
  limitType: 'users' | 'employees' | 'aiQueries' | 'storage',
  additionalUsage: number = 1
): Promise<{ allowed: boolean; warning?: string }> {
  // ... existing code ...

  const limits = await getEffectiveLimits(workspaceId) // Use effective limits

  // ... rest of the function
}
```

**Stripe Webhook Updates:**
```typescript
// Add to app/api/webhooks/stripe/route.ts

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  // ... existing code ...

  // Sync add-ons
  const workspaceId = subscription.metadata?.workspaceId
  if (!workspaceId) return

  // Get all subscription items (base + add-ons)
  for (const item of subscription.items.data) {
    const priceId = item.price.id

    // Check if it's an add-on
    const addon = AVAILABLE_ADDONS.find((a) => a.stripePriceId === priceId)
    if (addon) {
      // Update or create add-on record
      await prisma.workspaceAddOn.upsert({
        where: {
          workspaceId_addOnId: {
            workspaceId,
            addOnId: addon.id
          }
        },
        update: {
          quantity: item.quantity,
          stripeItemId: item.id
        },
        create: {
          workspaceId,
          addOnId: addon.id,
          quantity: item.quantity || 1,
          stripeItemId: item.id
        }
      })
    }
  }
}
```

**Invoice Display with Add-Ons:**
```typescript
// components/billing/invoice-list.tsx
function InvoiceRow({ invoice }: { invoice: any }) {
  return (
    <div className="p-4 border rounded-lg">
      <div className="flex items-center justify-between mb-2">
        <div>
          <p className="font-medium">
            â‚¬{(invoice.amount / 100).toFixed(2)}
          </p>
          <p className="text-sm text-gray-600">
            {new Date(invoice.created * 1000).toLocaleDateString()}
          </p>
        </div>
        <a
          href={invoice.invoicePdf}
          target="_blank"
          className="text-blue-600 hover:underline text-sm"
        >
          Download PDF
        </a>
      </div>

      {/* Line items */}
      {invoice.lines && invoice.lines.data.length > 0 && (
        <div className="mt-3 pt-3 border-t">
          <p className="text-xs font-medium text-gray-600 mb-2">Line Items:</p>
          {invoice.lines.data.map((line: any) => (
            <div key={line.id} className="flex justify-between text-sm">
              <span className="text-gray-700">{line.description}</span>
              <span className="text-gray-900">
                â‚¬{(line.amount / 100).toFixed(2)}
              </span>
            </div>
          ))}
        </div>
      )}
    </div>
  )
}
```

**Reference:** PRD Epic 5 Story 5.6, Stripe subscription items documentation, Architecture Section 14 (Subscription Management)

## Testing

**Unit Tests:**
- `getEffectiveLimits()` calculates correctly with add-ons
- Add-on benefits accumulate (2x employee add-ons = +20 employees)
- Storage add-ons convert correctly (5GB per add-on)

**Integration Tests:**
- Purchase employee add-on, verify usage limit increases
- Purchase storage add-on, verify storage limit increases
- Remove add-on, verify limit decreases
- Proration charges correctly on add/remove
- Webhook syncs add-on status

**Manual Testing:**
- Team tier (50 employees) + 1 employee add-on = 60 limit
- Add 2 employee add-ons, verify limit becomes 70
- Remove 1 add-on, verify limit becomes 60
- Check invoice shows base tier + add-ons separately
- Test proration (add add-on mid-month, verify prorated charge)

**Stripe Testing:**
- Use Stripe test mode
- Verify subscription items created correctly
- Check proration behavior
- Test add-on removal refunds correctly

**Test File:** `__tests__/features/billing/addons.test.ts`

## User vs Developer Responsibilities

**User Responsibility:**
- Choose appropriate add-ons based on needs
- Understand add-on pricing and proration
- Monitor usage to determine if add-ons needed

**Developer Responsibility:**
- Create Stripe Products for add-ons
- Handle proration correctly
- Update usage limits to include add-ons
- Sync add-on status via webhooks
- Display add-ons clearly on invoices
- Test add-on lifecycle thoroughly

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-11-12 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record
_To be populated by dev agent_

## QA Results
_To be populated by QA agent_
