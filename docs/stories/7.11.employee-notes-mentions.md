# Story 7.11: Add Employee Notes and @Mentions

## Status

Draft

## Story

**As an** HR manager,
**I want** to add notes to employee profiles and @mention teammates,
**so that** I collaborate on HR matters.

## Acceptance Criteria

1. Employee Profile → Notes section
2. Rich text editor (markdown supported)
3. @mention functionality: Type @ → Dropdown of team members
4. @mentioned users receive in-app notification
5. Notes timestamped and attributed to author
6. Edit/delete own notes only (or Admin/Owner can edit all)
7. Notes searchable via global search
8. Privacy: Notes only visible to HR Manager/Admin/Owner roles
9. Mobile-responsive notes interface

## Tasks / Subtasks

- [ ] Add Notes section to Employee Profile
- [ ] Integrate rich text editor with markdown support
- [ ] Implement @mention functionality
- [ ] Create in-app notification system
- [ ] Build note editing interface
- [ ] Implement note deletion with confirmation
- [ ] Add notes to global search index
- [ ] Apply role-based access control
- [ ] Test @mention notifications
- [ ] Test markdown rendering
- [ ] Test mobile responsiveness

## Dev Notes

**Database Schema:**

```prisma
model EmployeeNote {
  id         String   @id @default(uuid())
  employeeId String
  authorId   String
  content    String   @db.Text
  mentions   Json?    // Array of mentioned user IDs
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  author     User     @relation(fields: [authorId], references: [id])

  @@index([employeeId])
  @@index([authorId])
  @@map("employee_notes")
}

model Notification {
  id        String   @id @default(uuid())
  userId    String
  type      String   // mention, assignment, compliance_reminder, etc.
  title     String
  message   String
  link      String?
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
  @@index([createdAt])
  @@map("notifications")
}
```

**Notes Section in Employee Profile:**

```typescript
// components/hr/employee-notes.tsx
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { NoteEditor } from './note-editor'
import { NoteItem } from './note-item'

interface EmployeeNotesProps {
  employee: any
  currentUserId: string
  currentUserRole: string
}

export function EmployeeNotes({ employee, currentUserId, currentUserRole }: EmployeeNotesProps) {
  const router = useRouter()
  const [notes, setNotes] = useState(employee.notes || [])
  const [isAdding, setIsAdding] = useState(false)

  async function handleAddNote(content: string, mentions: string[]) {
    try {
      const response = await fetch(`/api/employees/${employee.id}/notes`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, mentions })
      })

      if (response.ok) {
        const { note } = await response.json()
        setNotes([note, ...notes])
        setIsAdding(false)
        router.refresh()
      } else {
        alert('Failed to add note')
      }
    } catch (error) {
      alert('Failed to add note')
    }
  }

  async function handleEditNote(noteId: string, content: string, mentions: string[]) {
    try {
      const response = await fetch(`/api/employees/${employee.id}/notes/${noteId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content, mentions })
      })

      if (response.ok) {
        const { note } = await response.json()
        setNotes(notes.map((n: any) => (n.id === noteId ? note : n)))
      } else {
        alert('Failed to update note')
      }
    } catch (error) {
      alert('Failed to update note')
    }
  }

  async function handleDeleteNote(noteId: string) {
    if (!confirm('Are you sure you want to delete this note?')) return

    try {
      const response = await fetch(`/api/employees/${employee.id}/notes/${noteId}`, {
        method: 'DELETE'
      })

      if (response.ok) {
        setNotes(notes.filter((n: any) => n.id !== noteId))
      } else {
        alert('Failed to delete note')
      }
    } catch (error) {
      alert('Failed to delete note')
    }
  }

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-lg font-semibold">Notes</h2>
        {!isAdding && (
          <button
            onClick={() => setIsAdding(true)}
            className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm"
          >
            Add Note
          </button>
        )}
      </div>

      {/* New Note Editor */}
      {isAdding && (
        <div className="mb-6 p-4 bg-gray-50 rounded-lg">
          <NoteEditor
            initialContent=""
            initialMentions={[]}
            employeeId={employee.id}
            onSave={handleAddNote}
            onCancel={() => setIsAdding(false)}
            submitLabel="Add Note"
          />
        </div>
      )}

      {/* Notes List */}
      {notes.length > 0 ? (
        <div className="space-y-4">
          {notes.map((note: any) => (
            <NoteItem
              key={note.id}
              note={note}
              currentUserId={currentUserId}
              currentUserRole={currentUserRole}
              onEdit={handleEditNote}
              onDelete={handleDeleteNote}
            />
          ))}
        </div>
      ) : (
        <div className="text-center py-12 text-gray-500">
          <p>No notes yet. Add a note to get started.</p>
        </div>
      )}
    </div>
  )
}
```

**Note Editor Component:**

```typescript
// components/hr/note-editor.tsx
'use client'

import { useState, useRef, useEffect } from 'react'
import ReactMarkdown from 'react-markdown'

interface NoteEditorProps {
  initialContent: string
  initialMentions: string[]
  employeeId: string
  onSave: (content: string, mentions: string[]) => Promise<void>
  onCancel: () => void
  submitLabel: string
}

export function NoteEditor({
  initialContent,
  initialMentions,
  employeeId,
  onSave,
  onCancel,
  submitLabel
}: NoteEditorProps) {
  const [content, setContent] = useState(initialContent)
  const [mentions, setMentions] = useState<string[]>(initialMentions)
  const [showMentionDropdown, setShowMentionDropdown] = useState(false)
  const [mentionSearch, setMentionSearch] = useState('')
  const [mentionPosition, setMentionPosition] = useState({ top: 0, left: 0 })
  const [teamMembers, setTeamMembers] = useState<any[]>([])
  const [isSaving, setIsSaving] = useState(false)
  const [showPreview, setShowPreview] = useState(false)
  const textareaRef = useRef<HTMLTextAreaElement>(null)

  useEffect(() => {
    // Fetch team members for @mentions
    fetch(`/api/workspace/members`)
      .then((res) => res.json())
      .then((data) => setTeamMembers(data.members))
  }, [])

  function handleContentChange(e: React.ChangeEvent<HTMLTextAreaElement>) {
    const newContent = e.target.value
    setContent(newContent)

    // Detect @mention
    const cursorPosition = e.target.selectionStart
    const textBeforeCursor = newContent.slice(0, cursorPosition)
    const lastAtIndex = textBeforeCursor.lastIndexOf('@')

    if (lastAtIndex !== -1 && lastAtIndex === cursorPosition - 1) {
      // Just typed @
      setShowMentionDropdown(true)
      setMentionSearch('')
      calculateMentionPosition(e.target, lastAtIndex)
    } else if (lastAtIndex !== -1 && cursorPosition > lastAtIndex) {
      // Typing after @
      const searchText = textBeforeCursor.slice(lastAtIndex + 1)
      if (!/\s/.test(searchText)) {
        setShowMentionDropdown(true)
        setMentionSearch(searchText)
        calculateMentionPosition(e.target, lastAtIndex)
      } else {
        setShowMentionDropdown(false)
      }
    } else {
      setShowMentionDropdown(false)
    }
  }

  function calculateMentionPosition(textarea: HTMLTextAreaElement, atIndex: number) {
    // Calculate position for mention dropdown (simplified)
    const rect = textarea.getBoundingClientRect()
    setMentionPosition({
      top: rect.bottom + window.scrollY,
      left: rect.left + window.scrollX + 20
    })
  }

  function selectMention(member: any) {
    const cursorPosition = textareaRef.current?.selectionStart || content.length
    const textBeforeCursor = content.slice(0, cursorPosition)
    const lastAtIndex = textBeforeCursor.lastIndexOf('@')

    const textAfterCursor = content.slice(cursorPosition)
    const newContent =
      content.slice(0, lastAtIndex) + `@${member.user.name} ` + textAfterCursor

    setContent(newContent)
    setMentions([...mentions, member.userId])
    setShowMentionDropdown(false)

    // Focus back on textarea
    setTimeout(() => textareaRef.current?.focus(), 0)
  }

  const filteredMembers = teamMembers.filter((member) =>
    member.user.name.toLowerCase().includes(mentionSearch.toLowerCase())
  )

  async function handleSave() {
    if (!content.trim()) {
      alert('Note cannot be empty')
      return
    }

    setIsSaving(true)
    try {
      await onSave(content, mentions)
    } finally {
      setIsSaving(false)
    }
  }

  return (
    <div className="relative">
      {/* Toolbar */}
      <div className="flex items-center justify-between mb-2">
        <div className="flex items-center gap-2">
          <button
            onClick={() => setShowPreview(!showPreview)}
            className="text-sm text-gray-600 hover:text-gray-900"
          >
            {showPreview ? 'Edit' : 'Preview'}
          </button>
          <span className="text-xs text-gray-400">Markdown supported</span>
        </div>
      </div>

      {/* Editor or Preview */}
      {showPreview ? (
        <div className="prose prose-sm max-w-none p-4 border border-gray-300 rounded-lg min-h-32 bg-gray-50">
          <ReactMarkdown>{content}</ReactMarkdown>
        </div>
      ) : (
        <textarea
          ref={textareaRef}
          value={content}
          onChange={handleContentChange}
          placeholder="Add a note... Use @ to mention team members"
          rows={6}
          className="w-full px-3 py-2 border border-gray-300 rounded-lg resize-none"
        />
      )}

      {/* Mention Dropdown */}
      {showMentionDropdown && filteredMembers.length > 0 && (
        <div
          className="absolute z-10 mt-1 w-64 bg-white border border-gray-300 rounded-lg shadow-lg max-h-48 overflow-y-auto"
          style={{ top: mentionPosition.top, left: mentionPosition.left }}
        >
          {filteredMembers.map((member) => (
            <button
              key={member.userId}
              onClick={() => selectMention(member)}
              className="w-full flex items-center gap-3 px-3 py-2 hover:bg-gray-50 text-left"
            >
              <Avatar src={member.user.photoUrl} name={member.user.name} size="sm" />
              <div>
                <p className="text-sm font-medium text-gray-900">{member.user.name}</p>
                <p className="text-xs text-gray-500">{member.role}</p>
              </div>
            </button>
          ))}
        </div>
      )}

      {/* Actions */}
      <div className="flex gap-3 mt-4">
        <button
          onClick={onCancel}
          disabled={isSaving}
          className="px-4 py-2 border border-gray-300 rounded-lg hover:bg-gray-50 text-sm disabled:bg-gray-100"
        >
          Cancel
        </button>
        <button
          onClick={handleSave}
          disabled={isSaving}
          className="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 text-sm disabled:bg-gray-300"
        >
          {isSaving ? 'Saving...' : submitLabel}
        </button>
      </div>
    </div>
  )
}
```

**Note Item Component:**

```typescript
// components/hr/note-item.tsx
'use client'

import { useState } from 'react'
import ReactMarkdown from 'react-markdown'
import { NoteEditor } from './note-editor'

interface NoteItemProps {
  note: any
  currentUserId: string
  currentUserRole: string
  onEdit: (noteId: string, content: string, mentions: string[]) => Promise<void>
  onDelete: (noteId: string) => Promise<void>
}

export function NoteItem({ note, currentUserId, currentUserRole, onEdit, onDelete }: NoteItemProps) {
  const [isEditing, setIsEditing] = useState(false)

  const canEdit = note.authorId === currentUserId || ['owner', 'admin'].includes(currentUserRole)

  async function handleSaveEdit(content: string, mentions: string[]) {
    await onEdit(note.id, content, mentions)
    setIsEditing(false)
  }

  return (
    <div className="border border-gray-200 rounded-lg p-4">
      {/* Header */}
      <div className="flex items-start justify-between mb-3">
        <div className="flex items-center gap-3">
          <Avatar src={note.author.photoUrl} name={note.author.name} size="sm" />
          <div>
            <p className="text-sm font-medium text-gray-900">{note.author.name}</p>
            <p className="text-xs text-gray-500">
              {new Date(note.createdAt).toLocaleString('sv-SE')}
              {note.updatedAt !== note.createdAt && ' (edited)'}
            </p>
          </div>
        </div>

        {canEdit && !isEditing && (
          <div className="flex gap-2">
            <button
              onClick={() => setIsEditing(true)}
              className="text-sm text-gray-600 hover:text-gray-900"
            >
              Edit
            </button>
            <button
              onClick={() => onDelete(note.id)}
              className="text-sm text-red-600 hover:text-red-700"
            >
              Delete
            </button>
          </div>
        )}
      </div>

      {/* Content */}
      {isEditing ? (
        <NoteEditor
          initialContent={note.content}
          initialMentions={note.mentions || []}
          employeeId={note.employeeId}
          onSave={handleSaveEdit}
          onCancel={() => setIsEditing(false)}
          submitLabel="Save"
        />
      ) : (
        <div className="prose prose-sm max-w-none">
          <ReactMarkdown>{note.content}</ReactMarkdown>
        </div>
      )}
    </div>
  )
}
```

**Create Note API with Notifications:**

```typescript
// app/api/employees/[id]/notes/route.ts
import { NextResponse } from 'next/server'
import { withWorkspace } from '@/lib/auth/with-workspace'
import { prisma } from '@/lib/prisma'

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  return withWorkspace(async ({ workspaceId, userId }) => {
    const { content, mentions } = await request.json()

    // Create note
    const note = await prisma.employeeNote.create({
      data: {
        employeeId: params.id,
        authorId: userId,
        content,
        mentions,
      },
      include: {
        author: {
          select: { name: true, email: true, photoUrl: true },
        },
      },
    })

    // Create notifications for mentioned users
    if (mentions && mentions.length > 0) {
      const employee = await prisma.employee.findUnique({
        where: { id: params.id },
        select: { name: true },
      })

      for (const mentionedUserId of mentions) {
        await prisma.notification.create({
          data: {
            userId: mentionedUserId,
            type: 'mention',
            title: 'You were mentioned in a note',
            message: `${note.author.name} mentioned you in a note about ${employee?.name}`,
            link: `/hr/employees/${params.id}`,
          },
        })
      }
    }

    return NextResponse.json({ note })
  })
}
```

**Notification Bell Component:**

```typescript
// components/layout/notification-bell.tsx
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'

export function NotificationBell() {
  const router = useRouter()
  const [notifications, setNotifications] = useState<any[]>([])
  const [showDropdown, setShowDropdown] = useState(false)
  const [unreadCount, setUnreadCount] = useState(0)

  useEffect(() => {
    fetchNotifications()

    // Poll for new notifications every 30 seconds
    const interval = setInterval(fetchNotifications, 30000)
    return () => clearInterval(interval)
  }, [])

  async function fetchNotifications() {
    const response = await fetch('/api/notifications')
    const data = await response.json()
    setNotifications(data.notifications)
    setUnreadCount(data.notifications.filter((n: any) => !n.read).length)
  }

  async function markAsRead(notificationId: string) {
    await fetch(`/api/notifications/${notificationId}/read`, { method: 'POST' })
    fetchNotifications()
  }

  async function markAllAsRead() {
    await fetch('/api/notifications/read-all', { method: 'POST' })
    fetchNotifications()
  }

  return (
    <div className="relative">
      <button
        onClick={() => setShowDropdown(!showDropdown)}
        className="relative p-2 text-gray-600 hover:text-gray-900 rounded-lg hover:bg-gray-100"
      >
        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
          />
        </svg>
        {unreadCount > 0 && (
          <span className="absolute top-1 right-1 w-5 h-5 bg-red-600 text-white text-xs rounded-full flex items-center justify-center">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {showDropdown && (
        <div className="absolute right-0 top-full mt-2 w-96 bg-white border border-gray-300 rounded-lg shadow-xl z-50 max-h-96 overflow-y-auto">
          <div className="flex items-center justify-between p-4 border-b border-gray-200">
            <h3 className="font-semibold">Notifications</h3>
            {unreadCount > 0 && (
              <button
                onClick={markAllAsRead}
                className="text-sm text-blue-600 hover:text-blue-700"
              >
                Mark all as read
              </button>
            )}
          </div>

          {notifications.length > 0 ? (
            <div className="divide-y divide-gray-200">
              {notifications.map((notification) => (
                <button
                  key={notification.id}
                  onClick={() => {
                    if (!notification.read) markAsRead(notification.id)
                    if (notification.link) router.push(notification.link)
                    setShowDropdown(false)
                  }}
                  className={`w-full p-4 text-left hover:bg-gray-50 ${
                    !notification.read ? 'bg-blue-50' : ''
                  }`}
                >
                  <p className="font-medium text-sm text-gray-900">{notification.title}</p>
                  <p className="text-sm text-gray-600 mt-1">{notification.message}</p>
                  <p className="text-xs text-gray-400 mt-2">
                    {new Date(notification.createdAt).toLocaleString('sv-SE')}
                  </p>
                </button>
              ))}
            </div>
          ) : (
            <div className="p-6 text-center text-gray-500">
              <p className="text-sm">No notifications</p>
            </div>
          )}
        </div>
      )}
    </div>
  )
}
```

**Reference:** PRD Epic 7 Story 7.11, ReactMarkdown documentation

## Testing

**Unit Tests:**

- Note editor detects @ symbol and shows mention dropdown
- Selecting mention inserts user name in content
- Markdown rendering works correctly
- Notification created when user mentioned

**Integration Tests:**

- Add note with @mention, verify notification sent
- Edit note, verify content updates
- Delete note, verify removed from database
- Search for note content in global search, verify found
- Test role-based access (non-HR cannot see notes)

**Manual Testing:**

- Type @ in note editor, verify dropdown appears with team members
- Select team member from dropdown, verify name inserted
- Add note with markdown (bold, italic, lists), verify renders correctly
- Click preview, verify markdown formatted correctly
- Save note, verify appears in notes list with timestamp
- Edit own note, verify can save changes
- Try to edit another user's note as regular user, verify blocked
- Edit another user's note as Admin, verify allowed
- Delete note, verify confirmation modal appears
- Add note mentioning teammate, verify they receive notification
- Click notification, verify navigates to employee profile

**Mobile Testing:**

- Note editor responsive on mobile
- @mention dropdown accessible on mobile
- Notes list scrollable on mobile
- Edit/delete buttons accessible on mobile

**Performance Testing:**

- Loading 100 notes on profile <2 seconds
- @mention dropdown appears instantly (<100ms)
- Notification polling every 30 seconds (low overhead)

**Security Testing:**

- Non-HR roles cannot view/add notes
- Cannot view notes for employees in other workspace
- @mentions only work for users in same workspace
- XSS prevention in markdown rendering (sanitize HTML)

**Test File:** `__tests__/features/hr/employee-notes.test.tsx`

## User vs Developer Responsibilities

**User Responsibility:**

- Write clear, professional notes
- Use @mentions appropriately (don't spam)
- Respect employee privacy (notes are internal only)
- Keep notes up-to-date and relevant

**Developer Responsibility:**

- Implement intuitive @mention functionality
- Send notifications reliably when users mentioned
- Render markdown safely (prevent XSS)
- Apply role-based access control strictly
- Make notes searchable in global search
- Optimize notification polling (balance freshness vs performance)
- Display notes chronologically with clear timestamps
- Allow editing with "edited" indicator
- Provide delete confirmation to prevent accidents

## Change Log

| Date       | Version | Description            | Author     |
| ---------- | ------- | ---------------------- | ---------- |
| 2025-11-12 | 1.0     | Initial story creation | Sarah (PO) |

## Dev Agent Record

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
