# Story 4.14: Document List Performance - Instant Switching and Optimistic Updates

## Status

Done

## Story

**As a** workspace user managing multiple document lists,
**I want** list switching and document additions to feel instant without loading spinners,
**so that** I can work fluidly across lists without interruption, especially in high-frequency usage scenarios.

## Acceptance Criteria

1. **Instant list switching (cached):**
   - Switch to a previously viewed list shows items immediately (<50ms)
   - Background refresh occurs without loading state
   - First visit to a list shows loading state (acceptable)

2. **Instant document addition:**
   - Clicking "Add" shows the document in the list immediately
   - No loading spinner visible during add operation
   - Failure shows error toast and removes the optimistic item

3. **No unnecessary refetches:**
   - Updating status/priority/assignee does NOT trigger full list reload
   - Only the affected item updates in the UI
   - Mutations complete without `fetchItems(true)` calls

4. **Cache management:**
   - Cache limited to last 10 lists to prevent memory bloat
   - Cache updates after every successful mutation
   - Cache persists during session (not required across page reload)

## Tasks / Subtasks

- [x] **Task 1: Add Per-List Item Cache to Zustand Store** (AC: 1, 4)
  - [x] Add `itemsByList: Map<string, { items: DocumentListItem[]; fetchedAt: number }>` state property
  - [x] Add `getCachedItems(listId: string)` selector that returns cached items or null
  - [x] Add `setCachedItems(listId: string, items: DocumentListItem[], total: number)` action
  - [x] Add `invalidateListCache(listId: string)` action for manual cache clearing
  - [x] Implement cache size limit (max 10 lists) with LRU eviction in `setCachedItems`
  - [x] Unit test: Cache stores and retrieves items correctly
  - [x] Unit test: Cache evicts oldest entry when exceeding 10 lists

- [x] **Task 2: Modify `setActiveList` for Instant Switching** (AC: 1)
  - [x] Check cache before fetching: `const cached = getCachedItems(listId)`
  - [x] If cached: Set `listItems` from cache immediately, then background refresh
  - [x] If not cached: Show loading state, fetch normally
  - [x] Ensure background refresh doesn't flash loading state (no `isLoadingItems: true` during revalidation)
  - [x] **IMPORTANT**: Background refresh must verify `activeListId` hasn't changed before applying fetched data (see Task 7 for stale response handling)
  - [x] Unit test: Cached list switch returns items without fetch call
  - [x] Unit test: Uncached list switch triggers fetch with loading state
  - [x] Unit test: Background refresh does not overwrite data if user switched lists during fetch

- [x] **Task 3: Implement True Optimistic `addItem`** (AC: 2)
  - [x] Create `createOptimisticItem(document: DocumentInfo, commentary?: string)` helper
  - [x] Generate temp ID: `temp-${Date.now()}`
  - [x] Add optimistic item to `listItems` immediately (before server call)
  - [x] Set `isAddingItem: false` immediately (no loading state)
  - [x] On success: Update cache with new items, optionally fetch full item data
  - [x] On failure: Remove temp item from `listItems`, set error message
  - [x] Update list item count in `lists` state on success
  - [x] Unit test: addItem creates optimistic item before server response
  - [x] Unit test: addItem rollback removes temp item on server error

- [x] **Task 4: Update Add Document Modal to Pass Document Info** (AC: 2)
  - [x] **BREAKING CHANGE**: Update `addItem` signature from `(listId, documentId, commentary?)` to `(listId, documentId, documentInfo, commentary?)`
  - [x] Update `DocumentListState` interface to reflect new `addItem` signature
  - [x] Update `AddDocumentModalProps.onAddDocument` type from `(documentId: string) => Promise<boolean>` to `(documentId: string, documentInfo: DocumentInfo) => Promise<boolean>`
  - [x] Modify `handleAdd` in modal to pass full document object:
    ```typescript
    const handleAdd = async (document: SearchResult) => {
      // ... existing guards ...
      const documentInfo: DocumentInfo = {
        id: document.id,
        title: document.title,
        documentNumber: document.documentNumber,
        contentType: document.contentType,
        slug: document.slug,
        summary: document.summary,
      }
      const success = await onAddDocument(document.id, documentInfo)
      // ... rest unchanged ...
    }
    ```
  - [x] Update all call sites of `addItem` in the codebase (search for usages)

- [x] **Task 5: Remove Unnecessary Refetch in `updateItem`** (AC: 3)
  - [x] Remove `fetchItems(true)` call after assignee update
  - [x] Update item locally with server response data (if assignee info returned)
  - [x] Apply same pattern to all field updates (status, priority, dueDate, notes)
  - [x] Call `setCachedItems` after successful local update
  - [x] Unit test: updateItem does not trigger fetchItems
  - [x] Unit test: updateItem updates only the affected item in state

- [x] **Task 6: Update Cache After All Mutations** (AC: 4)
  - [x] Add cache update call to `removeItem` after successful removal
  - [x] Add cache update call to `reorderItems` after successful reorder
  - [x] Add cache update call to `moveToGroup` after successful move
  - [x] Add cache update call to `bulkUpdateItems` after successful bulk update
  - [x] Add cache update call to `bulkMoveToGroup` after successful bulk move
  - [x] Create helper `updateActiveListCache()` to centralize cache update logic

- [x] **Task 7: Handle Race Conditions on Rapid List Switching** (AC: 1)
  - [x] Add `fetchAbortController: AbortController | null` to `DocumentListState` interface (after line ~69 with other loading states)
  - [x] Add `fetchAbortController: null` to `initialState` object
  - [x] Cancel in-flight fetch when switching lists: `abortController?.abort()`
  - [x] Create new AbortController for each fetch in `fetchItems`
  - [x] Pass AbortController signal to server action if supported, or check `activeListId` after fetch
  - [x] **CRITICAL**: After fetch completes, verify `activeListId` still matches the fetched listId before applying data:
    ```typescript
    // In fetchItems, after await:
    if (get().activeListId !== listIdBeingFetched) {
      return // Stale response - user switched lists
    }
    ```
  - [x] Unit test: Rapid list switches only apply the final list's data

- [x] **Task 8: Write E2E Tests for Performance Scenarios** (AC: 1, 2, 3)
  - [x] E2E: Switch between 3 lists rapidly - no loading spinners after first visit
  - [x] E2E: Add document - appears instantly in list (measure with performance timing if possible)
  - [x] E2E: Add document with simulated server error - disappears with error toast
  - [x] E2E: Update assignee - no full list flash/reload

## Dev Notes

### Previous Story Insights

[Source: Story 4.13 Dev Agent Record]

- **Optimistic update pattern established**: Store uses optimistic updates with rollback on error throughout 4.11-4.13
- **React.memo() for performance**: Applied to GroupAccordion and SortableCard components
- **useDebouncedCallback**: Used with 500ms for reorder operations
- **Test patterns**: 47 unit tests + 38 E2E tests established for document list functionality
- **File locations**: Store tests in `tests/unit/lib/stores/`, E2E in `tests/e2e/document-list.spec.ts`

### Data Models

[Source: docs/stories/briefs/document-list-caching-brief.md]

**New State Property:**

```typescript
itemsByList: Map<
  string,
  {
    items: DocumentListItem[]
    fetchedAt: number
  }
>
```

**DocumentInfo Interface (for optimistic item creation):**

```typescript
interface DocumentInfo {
  id: string
  title: string
  documentNumber: string
  contentType: ContentType
  slug: string
  summary?: string | null
}
```

### Key Code Changes

**Change 1: Per-List Cache Implementation**

```typescript
// In document-list-store.ts
itemsByList: new Map(),

getCachedItems: (listId: string) => {
  const cached = get().itemsByList.get(listId)
  if (!cached) return null
  return cached.items
},

setCachedItems: (listId, items, total) => {
  const cache = new Map(get().itemsByList)
  cache.set(listId, { items, fetchedAt: Date.now() })

  // LRU eviction: Keep last 10 lists
  if (cache.size > 10) {
    const oldest = [...cache.entries()]
      .sort((a, b) => a[1].fetchedAt - b[1].fetchedAt)[0]
    cache.delete(oldest[0])
  }

  set({ itemsByList: cache })
},
```

**Change 2: Modified setActiveList**

```typescript
setActiveList: (listId: string) => {
  const { activeListId, getCachedItems } = get()
  if (listId === activeListId) return

  const cachedItems = getCachedItems(listId)

  if (cachedItems) {
    // Instant switch from cache
    set({
      activeListId: listId,
      listItems: cachedItems,
    })
    // Background refresh (non-blocking, no loading state)
    get().fetchItems(true)
  } else {
    // No cache - show loading
    set({
      activeListId: listId,
      listItems: [],
      isLoadingItems: true,
    })
    get().fetchItems(true)
  }
},
```

**Change 3: True Optimistic addItem**

```typescript
addItem: async (listId, documentId, documentInfo, commentary?) => {
  const { listItems } = get()

  // Create optimistic item
  const tempId = `temp-${Date.now()}`
  const tempItem: DocumentListItem = {
    id: tempId,
    position: listItems.length,
    status: 'NOT_STARTED',
    priority: 'MEDIUM',
    commentary: commentary ?? null,
    notes: null,
    addedAt: new Date(),
    dueDate: null,
    assignee: null,
    groupId: null,
    groupName: null,
    document: documentInfo,
  }

  // Instant UI update
  set({
    listItems: [...listItems, tempItem],
    isAddingItem: false,
  })

  try {
    const result = await addDocumentToList({ listId, documentId, commentary })

    if (result.success) {
      // Update cache
      get().setCachedItems(listId, get().listItems, get().total + 1)
      // Update list count
      set(state => ({
        lists: state.lists.map(l =>
          l.id === listId ? { ...l, itemCount: l.itemCount + 1 } : l
        ),
      }))
      return true
    } else {
      // Rollback
      set({
        listItems: get().listItems.filter(i => i.id !== tempId),
        error: result.error ?? 'Kunde inte lägga till dokument',
      })
      return false
    }
  } catch {
    // Rollback on error
    set({
      listItems: get().listItems.filter(i => i.id !== tempId),
      error: 'Något gick fel',
    })
    return false
  }
},
```

**Change 4: Remove Refetch in updateItem**

```typescript
// REMOVE this block from updateItem:
if (updates.assignedTo !== undefined) {
  await get().fetchItems(true) // DELETE THIS LINE
}

// REPLACE with local state update only
// No fetchItems call needed - optimistic update already done
```

### File Locations

[Source: docs/architecture/12-unified-project-structure.md]

| Purpose            | Location                                                   |
| ------------------ | ---------------------------------------------------------- |
| Zustand Store      | `lib/stores/document-list-store.ts`                        |
| Add Document Modal | `components/features/document-list/add-document-modal.tsx` |
| Unit Tests         | `tests/unit/lib/stores/document-list-store.test.ts`        |
| E2E Tests          | `tests/e2e/document-list.spec.ts`                          |

### Technical Constraints

[Source: docs/architecture/17-coding-standards.md]

- **TypeScript strict mode**: All new properties must be properly typed
- **No `any` types**: Use proper interfaces for cache structure
- **Error handling**: Use ActionResult pattern for server calls
- **Immutability**: Use `new Map()` when updating cache, don't mutate existing

### Architecture Decision: Why Map Instead of Object

**Decision**: Use `Map<string, CacheEntry>` instead of `Record<string, CacheEntry>` for the item cache.

**Rationale**:

1. **Predictable iteration order**: Map maintains insertion order, essential for LRU eviction (oldest entry can be found via iteration)
2. **Better performance for frequent adds/deletes**: Map is optimized for this use case
3. **Clean size property**: `map.size` vs `Object.keys(obj).length`
4. **No prototype pollution risk**: Map keys are isolated from prototype chain
5. **Zustand compatibility**: Maps work well with Zustand's immutable update pattern via `new Map(existingMap)`

**Trade-off**: Maps don't serialize to JSON directly, but since this cache is session-only (not persisted), this is acceptable. The `partialize` function in the store already excludes this from persistence.

### Out of Scope (Future Phase)

[Source: docs/architecture/21-caching-and-data-fetching-strategy.md]

These are documented for future implementation and should NOT be included in this story:

- SWR integration for data fetching
- Redis caching for user-scoped data
- Supabase Realtime for multi-user sync
- Prefetch on hover
- Unified caching hooks (`useCachedQuery`, `useCachedMutation`)

## Testing

### Testing Standards

[Source: docs/architecture/17-coding-standards.md]

- **Unit Tests**: Vitest with `tests/unit/` structure
- **E2E Tests**: Playwright with `tests/e2e/` structure
- **Mocking**: MSW for server action calls (established in Story 4.13)

### MSW Mock Setup Pattern

[Source: Story 4.13 test patterns]

```typescript
// tests/unit/lib/stores/document-list-store.test.ts
import { http, HttpResponse } from 'msw'
import { setupServer } from 'msw/node'

const server = setupServer(
  // Mock successful add
  http.post('/api/document-list/add', () => {
    return HttpResponse.json({ success: true, data: { id: 'new-item-id' } })
  }),

  // Mock failed add (for rollback tests)
  http.post('/api/document-list/add-fail', () => {
    return HttpResponse.json({ success: false, error: 'Server error' })
  }),

  // Mock slow response (for race condition tests)
  http.get('/api/document-list/items/:listId', async ({ params }) => {
    await new Promise((r) => setTimeout(r, 100)) // Simulate latency
    return HttpResponse.json({
      success: true,
      data: { items: [], total: 0, hasMore: false },
    })
  })
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

### Performance Measurement in E2E Tests

```typescript
// tests/e2e/document-list.spec.ts
test('cached list switch is instant (<50ms perceived)', async ({ page }) => {
  // Visit list A first
  await page.click('[data-testid="list-item-A"]')
  await page.waitForSelector('[data-testid="document-card"]')

  // Visit list B
  await page.click('[data-testid="list-item-B"]')
  await page.waitForSelector('[data-testid="document-card"]')

  // Measure switch back to A
  const startTime = Date.now()
  await page.click('[data-testid="list-item-A"]')

  // Should NOT show loading skeleton
  const skeleton = page.locator('[data-testid="loading-skeleton"]')
  await expect(skeleton).not.toBeVisible()

  // Document cards should be visible immediately
  await expect(
    page.locator('[data-testid="document-card"]').first()
  ).toBeVisible()

  const elapsed = Date.now() - startTime
  expect(elapsed).toBeLessThan(100) // Allow some margin for test overhead
})

test('optimistic add shows item instantly', async ({ page }) => {
  // Open add modal, search, select document
  await page.click('[data-testid="add-document-btn"]')
  await page.fill('[data-testid="search-input"]', 'test')
  await page.waitForSelector('[data-testid="search-result"]')

  const startTime = Date.now()
  await page.click('[data-testid="add-btn"]')

  // Item should appear in list immediately (before modal closes)
  await expect(
    page.locator('[data-testid="document-card"]').last()
  ).toContainText('test')

  const elapsed = Date.now() - startTime
  expect(elapsed).toBeLessThan(100)
})
```

### Unit Test Requirements

| Test Case                                      | Expected Behavior                        |
| ---------------------------------------------- | ---------------------------------------- |
| `getCachedItems` returns null for unknown list | Returns null when listId not in cache    |
| `getCachedItems` returns items for cached list | Returns cached items array               |
| `setCachedItems` stores items correctly        | Items retrievable via getCachedItems     |
| `setCachedItems` evicts oldest when >10 lists  | Oldest entry removed, newest kept        |
| `setActiveList` uses cache when available      | No fetch call, instant state update      |
| `setActiveList` fetches when cache miss        | Fetch called with loading state          |
| `addItem` creates optimistic item instantly    | Item in listItems before await completes |
| `addItem` rollback on server error             | Temp item removed, error set             |
| `updateItem` no fetchItems call                | Only local state updated                 |
| Rapid list switch ignores stale responses      | Final list data applied                  |

### E2E Test Requirements

| Test Case          | Steps                                          | Expected                                  |
| ------------------ | ---------------------------------------------- | ----------------------------------------- |
| Cached list switch | Visit list A, visit list B, visit list A again | No loading spinner on second visit to A   |
| Rapid switching    | Switch A→B→C→B rapidly                         | Final state shows list B, no flickering   |
| Optimistic add     | Click add document                             | Item appears instantly (<100ms perceived) |
| Add rollback       | Add with network error                         | Item disappears, toast shown              |
| Update no reload   | Change assignee                                | List doesn't flash/reload                 |

## Change Log

| Date       | Version | Description                                                                                                                                 | Author     |
| ---------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| 2026-01-07 | 1.0     | Initial story creation from Architect brief                                                                                                 | Bob (SM)   |
| 2026-01-07 | 1.1     | PO validation fixes: Task 4 detail, Task 7 AbortController location, Task 2 race condition note, MSW patterns, Map ADR, E2E timing patterns | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

- Unit tests: 60 tests passing in `tests/unit/lib/stores/document-list-store.test.ts`
- TypeScript: No errors (`npx tsc --noEmit` passes)
- Lint: Only pre-existing console warnings in unrelated files

### Completion Notes

- Implemented per-list item cache with LRU eviction (max 10 lists)
- Added instant list switching from cache with background refresh
- Implemented true optimistic addItem that shows items immediately before server response
- Updated AddDocumentModal to pass DocumentInfo for optimistic item creation
- Removed unnecessary fetchItems(true) calls after mutations
- Added cache updates after all mutations (add, remove, update, reorder, move)
- Added race condition handling with stale response detection
- Added 4 E2E performance tests covering instant switching and optimistic updates
- All 60 unit tests pass, 4 new E2E tests added, 42 E2E tests pass
- **Bugfix:** Updated LeftSidebar to use Zustand store for lists, so deleting a list updates sidebar immediately without page refresh

### File List

| File                                                               | Action                                                                             |
| ------------------------------------------------------------------ | ---------------------------------------------------------------------------------- |
| `lib/stores/document-list-store.ts`                                | Modified - Added cache layer, optimistic updates, race condition handling          |
| `components/features/document-list/add-document-modal.tsx`         | Modified - Added DocumentInfoForAdd interface, pass document info to onAddDocument |
| `components/features/document-list/document-list-page-content.tsx` | Modified - Updated handleAddDocument and handleUpdateItem to use store methods     |
| `components/layout/left-sidebar.tsx`                               | Modified - Use Zustand store for lists (syncs with document list page)             |
| `tests/unit/lib/stores/document-list-store.test.ts`                | Modified - Added 14 new tests for Story 4.14 cache and optimistic functionality    |
| `tests/e2e/document-list.spec.ts`                                  | Modified - Added 4 new E2E performance tests                                       |

## QA Results

### Review Date: 2026-01-07

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent implementation** of performance optimizations for document list management. The implementation demonstrates:

- **Clean architecture**: Cache layer properly separated with clear actions (`getCachedItems`, `setCachedItems`, `invalidateListCache`, `updateActiveListCache`)
- **Robust optimistic updates**: True optimistic pattern with immediate UI feedback and proper rollback on failure
- **Race condition handling**: Stale response detection prevents data inconsistency during rapid list switching
- **Memory management**: LRU eviction strategy with 10-list cap prevents unbounded memory growth
- **Type safety**: All new types (`ListCacheEntry`, `DocumentInfo`, `DocumentInfoForAdd`) are explicitly defined

### Requirements Traceability

| AC  | Requirement                     | Implementation                                                            | Test Coverage               |
| --- | ------------------------------- | ------------------------------------------------------------------------- | --------------------------- |
| AC1 | Instant list switching (cached) | `setActiveList` checks cache, instant display, background refresh         | Unit: 2 tests, E2E: 2 tests |
| AC2 | Instant document addition       | `addItem` creates optimistic item with temp ID, rollback on error         | Unit: 3 tests, E2E: 1 test  |
| AC3 | No unnecessary refetches        | `updateItem` uses `updateActiveListCache()` instead of `fetchItems(true)` | E2E: 1 test                 |
| AC4 | Cache management                | LRU eviction at 10 lists, cache updates after all mutations               | Unit: 4 tests               |

### Refactoring Performed

No refactoring performed. The implementation is clean and follows established patterns.

### Compliance Check

- Coding Standards: ✓ TypeScript strict mode, no `any` types, proper error handling
- Project Structure: ✓ Files in correct locations per unified-project-structure
- Testing Strategy: ✓ Unit tests with Vitest + MSW mocks, E2E tests with Playwright
- All ACs Met: ✓ All 4 acceptance criteria fully implemented and tested

### Test Coverage Summary

| Test Type          | Count                      | Status        |
| ------------------ | -------------------------- | ------------- |
| Unit Tests (Store) | 60 total (14 new for 4.14) | ✓ All passing |
| E2E Tests          | 4 new performance tests    | ✓ All passing |
| TypeScript         | No errors                  | ✓ Clean       |

### Security Review

No security concerns. The implementation:

- Does not introduce new attack vectors
- Maintains proper authentication boundaries (server actions still require auth)
- Cache is session-only (not persisted) so no sensitive data leakage risk

### Performance Considerations

**Positive:**

- Instant list switching from cache (<50ms perceived)
- True optimistic updates eliminate UI blocking
- Background refresh keeps data fresh without user-visible loading
- LRU cache with 10-list limit prevents memory bloat

**Minor Note:**

- LRU eviction uses `sort()` which is O(n log n), but with max 10 entries this is negligible (<1ms)

### Files Modified During Review

None. Implementation is ready for production.

### Gate Status

Gate: **PASS** → docs/qa/gates/4.14-document-list-performance.yml

### Recommended Status

✓ **Ready for Done** - All acceptance criteria met, tests passing, code quality excellent.
