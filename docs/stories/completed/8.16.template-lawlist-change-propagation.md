# Story 8.16: LegalDocument Change Tracking & Notification Alignment

## Status

Done

## Story

**As a** platform,
**I need** every LegalDocument to carry its latest change type, reference, and timestamp directly,
**so that** all consumers (templates, law lists, notifications, search results) can display and act on change information from a single source of truth — without propagation logic or denormalized copies.

## Context & Dependencies

**Why this story was rewritten:**

v1 proposed propagating `ChangeEvent.amendment_sfs` into `TemplateItem.last_amendment` via a dedicated function. Review identified that this is the wrong approach:

1. `LegalDocument` has no field tracking its latest change — the data lives only in the `ChangeEvent` one-to-many relation, requiring a join + ORDER BY to answer "what changed last?"
2. `TemplateItem.last_amendment` is a denormalized copy that only covers amendments, not repeals or other change types
3. Every new consumer (notification emails, workspace law lists, search results, document detail pages) would need its own propagation — violating SSOT

The fix: add `last_change_type`, `last_change_ref`, and `last_change_at` directly to `LegalDocument`. Set them once when the change is detected. Every consumer reads from the document row.

**Builds on:**

- `sync-sfs-updates` cron — detects amendments, calls `detectChanges()` which creates `ChangeEvent` records [Source: app/api/cron/sync-sfs-updates/route.ts]
- `change-detection.ts` — `detectChanges()`, `createRepealEvent()`, `createNewLawEvent()`, `createNewRulingEvent()` [Source: lib/sync/change-detection.ts]
- Story 8.15 — `createAmendmentNotifications()` reads `ChangeEvent` to build notification text [Source: lib/notifications/amendment-notifications.ts]
- Story 0.1 — `shouldSendEmail()` and `NOTIFICATION_TYPE_TO_PREFERENCE` map [Source: lib/email/notification-preferences.ts]

**Depends on:** Story 8.15 must be merged (this story modifies `amendment-notifications.ts` and its tests).

**Depended on by:** Story 8.4 (Daily Email Digest) — benefits from correct notification text per change type. Story 8.5 (Notification Bell) — reads `Notification.type` which this story now populates correctly for all change types.

## Acceptance Criteria

### Schema: LegalDocument Change Fields

1. Add `last_change_type ChangeType?` to `LegalDocument` model — nullable, uses existing `ChangeType` enum (`AMENDMENT`, `REPEAL`, `NEW_LAW`, `METADATA_UPDATE`, `NEW_RULING`)
2. Add `last_change_ref String?` to `LegalDocument` model — the reference that caused the change (e.g., `"SFS 2026:145"`, `"AFS 2026:3"`), nullable because not all change types have a reference (e.g., `METADATA_UPDATE`)
3. Add `last_change_at DateTime?` to `LegalDocument` model — when the change was detected. Distinct from `updated_at` which is touched by any update (content refresh, metadata sync, etc.). This field is only set when a legal change (amendment, repeal, etc.) is detected.
4. Add `@@index([last_change_type])` to `LegalDocument` for filtering/sorting by change type
5. Create and apply Prisma migration (or `db push`)
6. Mark `TemplateItem.last_amendment` as deprecated in schema comment

### Set Fields in Change Detection Pipeline

7. `detectChanges()` sets `last_change_type = AMENDMENT`, `last_change_ref = amendmentSfs`, and `last_change_at = now()` on the LegalDocument within the same transaction
8. `createRepealEvent()` sets `last_change_type = REPEAL`, `last_change_ref = repealedBySfs`, and `last_change_at = now()` on the LegalDocument
9. `createNewLawEvent()` sets `last_change_type = NEW_LAW` and `last_change_at = now()` on the LegalDocument (`last_change_ref` = null)
10. `createNewRulingEvent()` sets `last_change_type = NEW_RULING` and `last_change_at = now()` on the LegalDocument (`last_change_ref` = null)
11. Idempotent: re-running sync for the same amendment produces the same field values (except `last_change_at` which reflects detection time)

### Export Preference Map

12. Export `NOTIFICATION_TYPE_TO_PREFERENCE` from `lib/email/notification-preferences.ts` — currently a private `const`, needs `export` keyword so `amendment-notifications.ts` can import it for dynamic preference lookup

### Generalize Story 8.15 Notification Creation

13. Rename `createAmendmentNotifications()` to `createChangeNotifications()` in `lib/notifications/amendment-notifications.ts`
14. Map `ChangeEvent.change_type` to the correct `NotificationType`:
    - `AMENDMENT` → `NotificationType.AMENDMENT_DETECTED`
    - `REPEAL` → `NotificationType.LAW_REPEALED`
    - `NEW_RULING` → `NotificationType.RULING_CITED`
    - `NEW_LAW` / `METADATA_UPDATE` → return early with zero stats (no user notification)
15. Build notification body text based on change type:
    - `AMENDMENT`: `"Ändrad genom ${ref}. ${aiSummary}"`
    - `REPEAL`: `"Upphävd genom ${ref}. ${aiSummary}"`
    - `NEW_RULING`: `"Nytt avgörande"` (with ai_summary if available)
16. Check the correct preference field per notification type by importing `NOTIFICATION_TYPE_TO_PREFERENCE` from `lib/email/notification-preferences.ts` — do NOT hardcode `amendment_detected_enabled`
17. Update `processChangeEventNotifications()` to call the renamed `createChangeNotifications()` internally. Do NOT rename the outer function — its name is already generic ("ChangeEvent" not "Amendment").
18. Update barrel export in `lib/notifications/index.ts`

### Downstream Documentation

19. Update references to the old `createAmendmentNotifications` function name in:
    - `docs/epics/epic-8-notifications.md` (lines 148, 212, 460)
    - `docs/epics/epic-8-execution-order.md` (line 21)
    - `docs/stories/8.19.agency-regulation-sync-cron.md` (lines 23, 66, 189, 218)

## Tasks / Subtasks

- [x] **Task 1: Schema migration** (AC: 1-6)
  - [x] Add `last_change_type ChangeType?` to `LegalDocument` in `prisma/schema.prisma` [Source: prisma/schema.prisma, LegalDocument model at line 281]
  - [x] Add `last_change_ref String?` to `LegalDocument` in `prisma/schema.prisma`
  - [x] Add `last_change_at DateTime?` to `LegalDocument` in `prisma/schema.prisma`
  - [x] Add `@@index([last_change_type])` to `LegalDocument` indexes
  - [x] Add `/// @deprecated Use LegalDocument.last_change_ref via document relation` comment to `TemplateItem.last_amendment` [Source: prisma/schema.prisma, TemplateItem model at line 1267]
  - [x] Run `pnpm prisma db push` to sync schema (or `pnpm prisma migrate dev --name add-legal-document-change-tracking` if shadow DB is available)
  - [x] Run `pnpm prisma generate` to update Prisma client types
  - [x] Verify with `npx tsc --noEmit` that no type errors introduced

- [x] **Task 2: Update change-detection.ts** (AC: 7-11) — depends on Task 1
  - [x] In `detectChanges()`: after `tx.changeEvent.create()`, add `tx.legalDocument.update()` within the same transaction to set `last_change_type: ChangeType.AMENDMENT`, `last_change_ref: amendmentSfs`, and `last_change_at: new Date()` [Source: lib/sync/change-detection.ts:150-222]
  - [x] In `createRepealEvent()`: add `tx.legalDocument.update()` to set `last_change_type: ChangeType.REPEAL`, `last_change_ref: repealedBySfs`, and `last_change_at: new Date()` [Source: lib/sync/change-detection.ts:255-269]
  - [x] In `createNewLawEvent()`: add `tx.legalDocument.update()` to set `last_change_type: ChangeType.NEW_LAW`, `last_change_ref: null`, and `last_change_at: new Date()` [Source: lib/sync/change-detection.ts:232-244]
  - [x] In `createNewRulingEvent()`: add `tx.legalDocument.update()` to set `last_change_type: ChangeType.NEW_RULING`, `last_change_ref: null`, and `last_change_at: new Date()` [Source: lib/sync/change-detection.ts:279-291]

- [x] **Task 3: Export preference map and generalize notification creation** (AC: 12-18) — depends on Task 1
  - [x] Add `export` keyword to `NOTIFICATION_TYPE_TO_PREFERENCE` in `lib/email/notification-preferences.ts` [Source: lib/email/notification-preferences.ts:11]
  - [x] Rename `createAmendmentNotifications` → `createChangeNotifications` in `lib/notifications/amendment-notifications.ts` [Source: lib/notifications/amendment-notifications.ts:23]
  - [x] Add helper `changeTypeToNotificationType(changeType: ChangeType): NotificationType | null`:
    - `AMENDMENT` → `AMENDMENT_DETECTED`
    - `REPEAL` → `LAW_REPEALED`
    - `NEW_RULING` → `RULING_CITED`
    - `NEW_LAW` / `METADATA_UPDATE` → `null` (skip)
  - [x] Add helper `notificationBodyForChangeType(changeType: ChangeType, ref: string | null, aiSummary: string | null): string`:
    - `AMENDMENT`: `"Ändrad genom ${ref}. ${snippet}"` or `"Ändrad genom ${ref}"`
    - `REPEAL`: `"Upphävd genom ${ref}. ${snippet}"` or `"Upphävd genom ${ref}"`
    - `NEW_RULING`: `snippet || "Nytt avgörande"`
    - Default: `snippet || "Uppdaterad"`
  - [x] In main function: after fetching ChangeEvent, call `changeTypeToNotificationType(changeEvent.change_type)`. If null → return zero stats early.
  - [x] Replace hardcoded `NotificationType.AMENDMENT_DETECTED` with the mapped type
  - [x] Replace hardcoded body construction with `notificationBodyForChangeType()`
  - [x] Import `NOTIFICATION_TYPE_TO_PREFERENCE` from `@/lib/email/notification-preferences`. Replace hardcoded `pref.amendment_detected_enabled` check with dynamic lookup: `const prefField = NOTIFICATION_TYPE_TO_PREFERENCE[notificationType]; if (prefField && pref && pref[prefField] === false)` [Source: lib/email/notification-preferences.ts:11-27]
  - [x] Update `processChangeEventNotifications` to call renamed `createChangeNotifications` internally (do NOT rename the outer function)
  - [x] Update barrel export in `lib/notifications/index.ts`: rename `createAmendmentNotifications` → `createChangeNotifications` [Source: lib/notifications/index.ts]

- [x] **Task 4: Update tests** (AC: all) — depends on Tasks 2-3
  - [x] Update `tests/unit/lib/sync/change-detection.test.ts`: add new `describe` block for DB-writing functions with mocked `tx` — 6 test cases (see Testing section)
  - [x] Update `tests/unit/lib/notifications/amendment-notifications.test.ts`: rename all `createAmendmentNotifications` references to `createChangeNotifications`, add 5 new change-type test cases (see Testing section)
  - [x] Verify all 13 existing notification tests still pass after rename
  - [x] Run full test suite (`pnpm vitest run`), verify no regressions

- [x] **Task 5: Update downstream documentation** (AC: 19)
  - [x] In `docs/epics/epic-8-notifications.md`: replace `createAmendmentNotifications` with `createChangeNotifications` (lines 148, 212, 460)
  - [x] In `docs/epics/epic-8-execution-order.md`: update function name reference (line 21)
  - [x] In `docs/stories/8.19.agency-regulation-sync-cron.md`: replace all `createAmendmentNotifications` references with `createChangeNotifications` (lines 23, 66, 189, 218)

## Dev Notes

### Previous Story Insights (from Story 8.15 Dev Agent Record)

- **Prisma mock pattern**: Use `vi.mock('@/lib/prisma')` to mock the Prisma client. Established in Story 0.1, continued in 8.15. [Source: Story 8.15 Dev Agent Record]
- **Prisma generate gotcha**: On Windows, `prisma generate` may fail with EPERM on DLL rename — kill running node processes first. [Source: Story 8.15 Debug Log]
- **Migration approach**: Used `prisma db push` instead of `prisma migrate dev` due to Supabase shadow database limitation (P3006 error). Schema synced to dev DB. Migration file should be created before merge to main. [Source: Story 8.15 Dev Agent Record]
- **`notification_sent` boundary**: `ChangeEvent.notification_sent` is NOT set by notification creation — that's Story 8.4's responsibility after email delivery. Do not change this boundary. [Source: Story 8.15, AC boundary note]
- **Enum usage**: Always use Prisma-generated enum values (`NotificationType.AMENDMENT_DETECTED`, `ChangeType.AMENDMENT`), never string literals. [Source: Story 8.15 Dev Notes]

### Data Models

**LegalDocument** (prisma/schema.prisma:281) [Source: prisma/schema.prisma]
```prisma
model LegalDocument {
  // ... existing fields ...
  last_change_type ChangeType?              // NEW: What happened most recently
  last_change_ref  String?                  // NEW: Causing document ref (e.g., "SFS 2026:145")
  last_change_at   DateTime?               // NEW: When the change was detected

  // ... existing indexes ...
  @@index([last_change_type])               // NEW: For filtering/sorting by change type
  // ... relations ...
}
```
New fields are nullable — existing documents will have `null` until their next sync run detects a change. See "Backfill Strategy" section below for addressing historical data.

**ChangeType enum** (prisma/schema.prisma:425) [Source: prisma/schema.prisma]
```prisma
enum ChangeType {
  NEW_LAW
  AMENDMENT
  REPEAL
  METADATA_UPDATE
  NEW_RULING
}
```
Already exists — no enum changes needed. `last_change_type` reuses this.

**ChangeEvent** (prisma/schema.prisma:800) [Source: prisma/schema.prisma]
- `change_type: ChangeType` — the event type
- `amendment_sfs: String?` — the causing reference (e.g., `"SFS 2026:145"`)
- `document_id: String` — FK to the base `LegalDocument`

**TemplateItem** (prisma/schema.prisma:1267) [Source: prisma/schema.prisma]
- `last_amendment: String?` — currently manually maintained, to be marked `@deprecated`
- `document_id: String` — FK to `LegalDocument` (can join to get `last_change_ref` instead)

**NotificationType enum** [Source: prisma/schema.prisma, added by Story 8.15]
```prisma
enum NotificationType {
  // ... existing workspace types ...
  AMENDMENT_DETECTED    // maps from ChangeType.AMENDMENT
  LAW_REPEALED          // maps from ChangeType.REPEAL
  RULING_CITED          // maps from ChangeType.NEW_RULING
  AMENDMENT_REMINDER    // future Story 8.6
}
```

### Preference Map

`NOTIFICATION_TYPE_TO_PREFERENCE` in `lib/email/notification-preferences.ts` already maps all 4 Epic 8 types to their preference fields (added by Story 8.15). **This story adds `export` to the map declaration** so it can be imported by `amendment-notifications.ts`. [Source: lib/email/notification-preferences.ts:11-27]

```typescript
// BEFORE (Story 8.15): private const
const NOTIFICATION_TYPE_TO_PREFERENCE: Partial<...> = { ... }

// AFTER (this story): exported
export const NOTIFICATION_TYPE_TO_PREFERENCE: Partial<...> = { ... }
```

To use dynamically in notification creation:
```typescript
import { NOTIFICATION_TYPE_TO_PREFERENCE } from '@/lib/email/notification-preferences'
import { NotificationType } from '@prisma/client'

const prefField = NOTIFICATION_TYPE_TO_PREFERENCE[notificationType]
if (prefField && pref && pref[prefField] === false) {
  // skip this user
}
```

### Existing `metadata.latestAmendment` Field

The `sync-sfs-updates` cron already writes `latestAmendment` into `LegalDocument.metadata` JSON [Source: app/api/cron/sync-sfs-updates/route.ts:372]:
```typescript
metadata: {
  ...((existing.metadata as object) || {}),
  latestAmendment,
  lastSyncAt: new Date().toISOString(),
}
```
This is a third location storing amendment info (alongside the new `last_change_ref` and deprecated `TemplateItem.last_amendment`). **Do NOT remove `metadata.latestAmendment` in this story** — it is used by the sync cron's own logic. The new `last_change_ref` field is the canonical source for consumers. Cleanup of `metadata.latestAmendment` is deferred to a future housekeeping story.

### Key Data Flow (after this story)

```
sync-sfs-updates detects change
  -> change-detection.ts creates ChangeEvent
  -> SAME TRANSACTION: sets LegalDocument.last_change_type + last_change_ref + last_change_at
  -> Later: notification cron calls createChangeNotifications(changeEventId)
    -> Reads ChangeEvent.change_type
    -> Maps to correct NotificationType (AMENDMENT_DETECTED, LAW_REPEALED, etc.)
    -> Builds body text per type
    -> Imports NOTIFICATION_TYPE_TO_PREFERENCE, checks correct preference per type
    -> Creates Notification records

Any consumer reads LegalDocument:
  -> last_change_type = AMENDMENT
  -> last_change_ref = "SFS 2026:145"
  -> last_change_at = 2026-02-17T04:30:00Z
  -> No join to ChangeEvent needed for display
```

### change-detection.ts Modification Pattern

All four event-creating functions follow the same pattern. Each already receives a `tx` (transaction client) and a `documentId`. The addition is a single `tx.legalDocument.update()` call:

```typescript
// Example for detectChanges() — same pattern for all four functions
export async function detectChanges(
  tx: TransactionClient,
  params: DetectChangesParams
): Promise<ChangeEvent | null> {
  // ... existing logic ...

  const changeEvent = await tx.changeEvent.create({ data: createData })

  // NEW: Set change tracking fields on the base document
  await tx.legalDocument.update({
    where: { id: documentId },
    data: {
      last_change_type: ChangeType.AMENDMENT,
      last_change_ref: amendmentSfs,
      last_change_at: new Date(),
    },
  })

  return changeEvent
}
```

**Important**: `detectChanges()` returns `null` if no substantive changes are detected (line 165-167). The `legalDocument.update()` must only run when a ChangeEvent is actually created — i.e., after the null guard, not before.

### Notification Type Mapping

```typescript
import { ChangeType, NotificationType } from '@prisma/client'

export function changeTypeToNotificationType(
  changeType: ChangeType
): NotificationType | null {
  switch (changeType) {
    case ChangeType.AMENDMENT:      return NotificationType.AMENDMENT_DETECTED
    case ChangeType.REPEAL:         return NotificationType.LAW_REPEALED
    case ChangeType.NEW_RULING:     return NotificationType.RULING_CITED
    case ChangeType.NEW_LAW:        return null  // No notification
    case ChangeType.METADATA_UPDATE: return null // No notification
  }
}
```

### Notification Body Text

```typescript
export function notificationBodyForChangeType(
  changeType: ChangeType,
  ref: string | null,
  aiSummary: string | null
): string {
  const snippet = aiSummary ? aiSummary.slice(0, 150) : ''
  const refStr = ref ?? 'okänd'

  switch (changeType) {
    case ChangeType.AMENDMENT:
      return snippet ? `Ändrad genom ${refStr}. ${snippet}` : `Ändrad genom ${refStr}`
    case ChangeType.REPEAL:
      return snippet ? `Upphävd genom ${refStr}. ${snippet}` : `Upphävd genom ${refStr}`
    case ChangeType.NEW_RULING:
      return snippet || 'Nytt avgörande'
    default:
      return snippet || 'Uppdaterad'
  }
}
```

### Why NOT Remove TemplateItem.last_amendment Now

Existing template editor (Story 12.7b) and catalog (Story 12.9) may read this field. Removing it requires auditing and updating those consumers. This story marks it deprecated; a follow-up cleanup story handles removal and migrates reads to `document.last_change_ref`.

### Backfill Strategy for Existing Documents

New fields are nullable, so existing documents will have `null` until their next sync run detects a change. For stable laws that rarely change, this could mean `null` indefinitely. A one-time backfill is NOT required for this story but is recommended as a follow-up:

```sql
-- Example backfill: populate from most recent ChangeEvent per document
UPDATE legal_documents ld
SET last_change_type = ce.change_type,
    last_change_ref = ce.amendment_sfs,
    last_change_at = ce.detected_at
FROM (
  SELECT DISTINCT ON (document_id) document_id, change_type, amendment_sfs, detected_at
  FROM change_events
  ORDER BY document_id, detected_at DESC
) ce
WHERE ld.id = ce.document_id;
```

This should be tracked as a follow-up task, not part of this story's implementation.

### File Locations

Per project structure [Source: architecture/12-unified-project-structure.md]:

```
prisma/schema.prisma                            — MODIFY: LegalDocument +3 fields +1 index, TemplateItem deprecation comment

lib/sync/change-detection.ts                    — MODIFY: add legalDocument.update() in all 4 event creators

lib/notifications/
  |- amendment-notifications.ts                 — MODIFY: rename function, generalize for all change types
  |- recipient-resolution.ts                    — NO CHANGES
  +- index.ts                                   — MODIFY: update barrel re-exports

lib/email/notification-preferences.ts           — MODIFY: add export to NOTIFICATION_TYPE_TO_PREFERENCE

docs/epics/epic-8-notifications.md              — MODIFY: update function name references
docs/epics/epic-8-execution-order.md            — MODIFY: update function name reference
docs/stories/8.19.agency-regulation-sync-cron.md — MODIFY: update function name references
```

Import aliases: use `@/lib/notifications/...`, `@/lib/prisma`, `@prisma/client`, `@/lib/email/notification-preferences` [Source: architecture/12-unified-project-structure.md#12.5]

### UI Standards

- No UI in this story — pure backend
- The new `last_change_type` / `last_change_ref` / `last_change_at` fields surface wherever a LegalDocument is displayed (templates, law lists, search results, document detail pages) — those UIs read from the document relation

## Testing

**Test framework:** Vitest 1.4+ with `vi.mock()` for Prisma [Source: architecture/3-tech-stack.md#Backend Testing]

**Mocking strategy:** Mock `@/lib/prisma` using `vi.mock()`. Never hit real database. Use `vi.mocked()` for type-safe mock assertions. [Source: Story 8.15 Dev Notes, established pattern]

### Test File: `tests/unit/lib/sync/change-detection.test.ts` (update existing)

The existing file only tests pure functions (`computeDiff`, `generateUnifiedDiff`, `hasSubstantiveChanges`). Add a new `describe` block for the DB-writing functions with a mocked `tx` object:

- `detectChanges()` calls `tx.legalDocument.update` with `last_change_type = AMENDMENT`, `last_change_ref` matching `amendmentSfs`, and `last_change_at` as a Date
- `detectChanges()` does NOT call `tx.legalDocument.update` when no substantive changes detected (returns null)
- `createRepealEvent()` calls `tx.legalDocument.update` with `last_change_type = REPEAL` and correct `last_change_ref`
- `createNewLawEvent()` calls `tx.legalDocument.update` with `last_change_type = NEW_LAW` and `last_change_ref = null`
- `createNewRulingEvent()` calls `tx.legalDocument.update` with `last_change_type = NEW_RULING` and `last_change_ref = null`
- Idempotency: calling `detectChanges()` twice with same params produces same `last_change_type` / `last_change_ref` values

### Test File: `tests/unit/lib/notifications/amendment-notifications.test.ts` (update existing)

Existing tests reference `createAmendmentNotifications` — rename to `createChangeNotifications`. Then add:

- AMENDMENT ChangeEvent → creates `AMENDMENT_DETECTED` notification with `"Ändrad genom ..."` body (existing tests, renamed)
- REPEAL ChangeEvent → creates `LAW_REPEALED` notification with `"Upphävd genom ..."` body
- NEW_RULING ChangeEvent → creates `RULING_CITED` notification with `"Nytt avgörande"` or ai_summary
- NEW_LAW ChangeEvent → creates NO notifications, returns zero stats
- METADATA_UPDATE ChangeEvent → creates NO notifications, returns zero stats
- Correct preference field checked per notification type:
  - AMENDMENT → checks `amendment_detected_enabled`
  - REPEAL → checks `law_repealed_enabled`
  - NEW_RULING → checks `ruling_cited_enabled`
- Existing tests for idempotency, batch processing, fallback body, empty recipients — update function names but verify still passing

### Test File: `tests/unit/lib/notifications/recipient-resolution.test.ts`

No changes — recipient resolution is document-agnostic, already works for all change types.

### Test File: `tests/unit/lib/email/notification-preferences.test.ts`

No changes — preference map tests already cover all 4 Epic 8 types from Story 8.15. The `export` keyword addition does not affect test behavior.

## Change Log

| Date       | Version | Description                  | Author     |
| ---------- | ------- | ---------------------------- | ---------- |
| 2026-02-17 | 1.0     | Initial story creation (template propagation approach) | Sarah (PO) |
| 2026-02-17 | 2.0     | Rewritten: SSOT on LegalDocument, drop propagation pattern, align 8.15 notifications. Enriched with architecture source references and 8.15 dev insights. | Bob (SM) |
| 2026-02-17 | 2.1     | PO validation: Fixed unexported preference map (C1), clarified processChangeEventNotifications rename scope (S1), added downstream doc update task (S2), expanded Task 4 subtasks (S3), documented metadata.latestAmendment coexistence (S4), added last_change_at timestamp field (N1), added backfill strategy note (N2), added index for last_change_type (N3). Status: Draft → Approved. | Sarah (PO) |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6

### Debug Log References

No blocking issues encountered.

### Completion Notes

- Schema: Added 3 nullable fields (`last_change_type`, `last_change_ref`, `last_change_at`) + index to `LegalDocument`. DB pushed successfully via `prisma db push`.
- `TemplateItem.last_amendment` marked with `/// @deprecated` comment.
- `change-detection.ts`: All 4 event creators (`detectChanges`, `createNewLawEvent`, `createRepealEvent`, `createNewRulingEvent`) now set `LegalDocument` change tracking fields within the same transaction. `detectChanges` only writes when substantive changes detected (after null guard).
- `notification-preferences.ts`: `NOTIFICATION_TYPE_TO_PREFERENCE` exported (was private `const`).
- `amendment-notifications.ts`: `createAmendmentNotifications` → `createChangeNotifications`. Added `changeTypeToNotificationType()` and `notificationBodyForChangeType()` helpers. Preference check now uses dynamic lookup via imported map instead of hardcoded `amendment_detected_enabled`. `NEW_LAW` and `METADATA_UPDATE` return early with zero stats.
- Barrel export in `lib/notifications/index.ts` updated.
- 85 tests passing across 4 test files (36 change-detection + 33 notification + 11 preferences + 5 recipient-resolution). Full regression: no new failures introduced.
- Downstream docs updated: `epic-8-notifications.md`, `epic-8-execution-order.md`, `8.19.agency-regulation-sync-cron.md`.
- Pre-existing `headerText` unused var in `emails/components/laglig-email-layout.tsx` — not in scope.

### File List

| File | Action |
|------|--------|
| `prisma/schema.prisma` | Modified — LegalDocument +3 fields +1 index, TemplateItem deprecation comment |
| `lib/sync/change-detection.ts` | Modified — `tx.legalDocument.update()` in all 4 event creators |
| `lib/notifications/amendment-notifications.ts` | Modified — rename + generalize for all change types |
| `lib/notifications/index.ts` | Modified — barrel re-exports updated |
| `lib/email/notification-preferences.ts` | Modified — exported `NOTIFICATION_TYPE_TO_PREFERENCE` |
| `tests/unit/lib/sync/change-detection.test.ts` | Modified — added 6 DB-writing function tests |
| `tests/unit/lib/notifications/amendment-notifications.test.ts` | Modified — renamed + added 7 new change-type tests |
| `docs/epics/epic-8-notifications.md` | Modified — function name references |
| `docs/epics/epic-8-execution-order.md` | Modified — function name reference |
| `docs/stories/8.19.agency-regulation-sync-cron.md` | Modified — function name references |
| `docs/stories/8.16.template-lawlist-change-propagation.md` | Modified — checkboxes, dev agent record, status |

### Change Log

| Date | Description |
|------|-------------|
| 2026-02-17 | Implementation complete — all 5 tasks done, 85 tests passing, status → Ready for Review |

## QA Results

### Review Date: 2026-02-17

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

High-quality implementation. Clean separation of concerns with pure helper functions (`changeTypeToNotificationType`, `notificationBodyForChangeType`) extracted and independently testable. Transaction boundaries correctly maintained — `legalDocument.update()` only fires after the null guard in `detectChanges()`. The switch from hardcoded preference field to dynamic map lookup is a well-executed SSOT pattern. Exhaustive `switch` on Prisma enums ensures compile-time safety if new `ChangeType` values are added.

### Refactoring Performed

None required. Implementation is clean and well-structured.

### Compliance Check

- Coding Standards: ✓ — TypeScript strict, Prisma enum values (not string literals), proper imports via `@/` aliases
- Project Structure: ✓ — Files in correct locations per architecture/12-unified-project-structure.md
- Testing Strategy: ✓ — 85 tests across 4 files; unit tests with mocked Prisma; pure functions tested separately
- All ACs Met: ✓ — All 19 acceptance criteria verified (see traceability below)

### Requirements Traceability

| AC | Implementation | Test Coverage |
|----|---------------|--------------|
| 1-3 | `prisma/schema.prisma:305-308` — 3 nullable fields | Type-check passing |
| 4 | `prisma/schema.prisma:335` — `@@index([last_change_type])` | Type-check passing |
| 5 | `prisma db push` executed | DB sync confirmed |
| 6 | `prisma/schema.prisma:1284` — `/// @deprecated` comment | Visual inspection |
| 7 | `change-detection.ts:221-229` — AMENDMENT update in tx | `change-detection.test.ts:404-423` |
| 8 | `change-detection.ts:292-300` — REPEAL update in tx | `change-detection.test.ts:462-486` |
| 9 | `change-detection.ts:255-263` — NEW_LAW update in tx | `change-detection.test.ts:489-507` |
| 10 | `change-detection.ts:326-334` — NEW_RULING update in tx | `change-detection.test.ts:510-528` |
| 11 | Idempotent by design (same values on re-run) | `change-detection.test.ts:440-459` |
| 12 | `notification-preferences.ts:11` — `export` added | Import verified in amendment-notifications.ts |
| 13 | `amendment-notifications.ts:75` — renamed | 20+ tests reference new name |
| 14 | `amendment-notifications.ts:17-32` — `changeTypeToNotificationType()` | 5 dedicated unit tests |
| 15 | `amendment-notifications.ts:37-59` — `notificationBodyForChangeType()` | 8 dedicated unit tests |
| 16 | `amendment-notifications.ts:126,140` — dynamic preference lookup | `amendment-notifications.test.ts:402-438` |
| 17 | `amendment-notifications.ts:196` — internal call updated | `processChangeEventNotifications` tests passing |
| 18 | `index.ts` — barrel exports updated | Import resolution working |
| 19 | 3 doc files updated, verified via grep (0 stale refs) | N/A |

### Improvements Checklist

- [x] All 19 ACs implemented and tested
- [x] Type-check clean (no new errors)
- [x] 85/85 tests passing
- [x] Downstream documentation updated
- [x] Null-ref fallback text (`'okänd'`) is consistent across AMENDMENT and REPEAL paths
- [ ] **Minor (future)**: Consider renaming the file `amendment-notifications.ts` to `change-notifications.ts` to match the renamed function. Non-blocking — file name is internal and barrel export insulates consumers.

### Security Review

No security concerns. This is a backend-only change touching internal pipeline code. No user input handling, no auth changes, no API surface changes.

### Performance Considerations

No concerns. The added `legalDocument.update()` call in each transaction is a single indexed write by primary key — negligible cost. The `@@index([last_change_type])` enables efficient filtering for future consumer queries.

### Files Modified During Review

No files modified by QA.

### Gate Status

Gate: **PASS** → `docs/qa/gates/8.16-notification-alignment.yml`

### Recommended Status

✓ **Ready for Done** — All ACs met, comprehensive test coverage, clean architecture, no blocking issues.
