# Story 8.18: Agency Website Adapter Pattern & Change Detection

## Status

Draft (v1 — new story, created 2026-02-17)

## Story

**As a** platform,
**I need** a per-agency adapter pattern that can check agency websites for new or updated regulations,
**so that** we detect changes to myndighetsforeskrifter automatically rather than relying on manual checks.

## Context & Dependencies

**Why this story exists:**

Unlike SFS laws (which have a unified Riksdagen API), each Swedish agency publishes regulations on their own website with different structures, formats, and publishing patterns. We need a pluggable adapter system where each agency has its own change detection logic, but all adapters feed into the same downstream pipeline.

**Builds on:**

- Story 8.17 (Expand Ingestion) — provides baseline documents with content hashes to diff against
- `lib/agency/afs-scraper.ts` — proven HTML scraping for AFS (pattern to generalize)
- `lib/agency/agency-pdf-registry.ts` — knows document URLs per agency
- `LegalDocument.metadata.contentHash` — stored by Story 8.17 for comparison

**Depends on:**

- Story 8.17 (must have baseline content + content hashes to compare against)

**Depended on by:**

- Story 8.19 (Sync Cron) — orchestrates adapters on a schedule

## Acceptance Criteria

### Adapter Interface

1. Define `AgencyAdapter` interface in `lib/agency/adapters/types.ts`:
   ```typescript
   interface AgencyAdapter {
     agencyCode: AgencyAuthority
     displayName: string
     checkForUpdates(): Promise<AgencyUpdateResult[]>
     fetchDocumentContent(documentNumber: string): Promise<DocumentContent | null>
   }
   ```
2. `AgencyUpdateResult` type:
   ```typescript
   interface AgencyUpdateResult {
     documentNumber: string
     changeType: 'NEW' | 'UPDATED' | 'REMOVED'
     currentUrl: string
     detectedAt: Date
     details?: string  // e.g., "Content hash changed", "New document found"
   }
   ```
3. `DocumentContent` type:
   ```typescript
   interface DocumentContent {
     html: string
     contentHash: string
     fetchedAt: Date
     sourceUrl: string
   }
   ```

### Adapter Registry

4. Create adapter registry in `lib/agency/adapters/index.ts` that maps `AgencyAuthority` → `AgencyAdapter` instance
5. Registry supports lazy loading of adapters (don't instantiate all at import time)
6. `getAdapter(agencyCode)` returns the adapter or `null` if not implemented
7. `getImplementedAdapters()` returns list of all agency codes with working adapters

### Change Detection Strategies

8. **Strategy A — HTML content comparison (for AFS):**
   - Re-scrape regulation page using existing `afs-scraper.ts`
   - Compute `sha256(html_content)` of scraped content
   - Compare against stored `metadata.contentHash`
   - If different: report as `UPDATED`
   - If page returns 404 or removed: report as `REMOVED`

9. **Strategy B — PDF URL/date comparison (for most other agencies):**
   - Fetch the regulation's landing page (from `AgencyPdfDocument.sourceUrl`)
   - Extract PDF download link and any "last updated" / "version" metadata from the page
   - Compare PDF URL against stored `metadata.pdfUrl`
   - If URL changed or version number increased: report as `UPDATED`
   - Optionally: download PDF, compute hash, compare against stored hash (more reliable but slower)

10. **Strategy C — Listing page scan (for new documents):**
    - Fetch the agency's regulation listing page
    - Extract all regulation document numbers
    - Compare against our database
    - New document numbers not in DB: report as `NEW`

### Priority Adapters

11. Implement AFS adapter (HTML scraping via existing pipeline)
12. Implement at least 2 PDF-based adapters for agencies in published templates (from: NFS, MSBFS, ELSAK-FS, KIFS, BFS)
13. Each adapter includes inline documentation of the agency's website structure and any known quirks

### Error Handling

14. Each adapter method must not throw — return empty array on network errors, log warnings
15. Adapter-level timeout: max 30 seconds per agency check
16. Rate limiting: max 5 concurrent requests per agency (respect website)
17. User-Agent header identifies our bot: `"Laglig.se/1.0 (legal-compliance-monitor)"`

## Tasks / Subtasks

- [ ] **Task 1: Define adapter types and interface** (AC: 1-3)
  - [ ] Create `lib/agency/adapters/types.ts` with interfaces
  - [ ] Export from `lib/agency/adapters/index.ts`
- [ ] **Task 2: Build adapter registry** (AC: 4-7)
  - [ ] Create `lib/agency/adapters/index.ts` with registry map
  - [ ] Implement `getAdapter()` and `getImplementedAdapters()`
  - [ ] Lazy loading pattern
- [ ] **Task 3: Build AFS adapter** (AC: 8, 11)
  - [ ] Create `lib/agency/adapters/afs-adapter.ts`
  - [ ] Reuse `afs-scraper.ts` for content fetching
  - [ ] Implement `checkForUpdates()`: iterate known AFS documents, scrape, compare hash
  - [ ] Implement `fetchDocumentContent()`: scrape + transform + return
- [ ] **Task 4: Build generic PDF adapter base** (AC: 9-10)
  - [ ] Create `lib/agency/adapters/pdf-adapter-base.ts`
  - [ ] Shared logic: fetch landing page, extract PDF link, compare URLs/hashes
  - [ ] Abstract method for page-specific selectors (each agency extends this)
- [ ] **Task 5: Build NFS adapter** (AC: 12)
  - [ ] Create `lib/agency/adapters/nfs-adapter.ts` extending PDF base
  - [ ] Research naturvardsverket.se page structure
  - [ ] Implement agency-specific selectors for PDF link extraction
  - [ ] Test against known NFS documents
- [ ] **Task 6: Build MSBFS adapter** (AC: 12)
  - [ ] Create `lib/agency/adapters/msbfs-adapter.ts` extending PDF base
  - [ ] Research mcf.se page structure
  - [ ] Implement agency-specific selectors
  - [ ] Test against known MSBFS documents
- [ ] **Task 7: Error handling and rate limiting** (AC: 14-17)
  - [ ] Wrap all fetch calls with timeout
  - [ ] Add concurrency limiter (p-limit or similar)
  - [ ] Set User-Agent header
  - [ ] Log warnings on failures, return empty results

## Dev Notes

### Source Tree

```
lib/agency/adapters/                        — NEW directory
  ├── types.ts                              — AgencyAdapter interface, result types
  ├── index.ts                              — Adapter registry
  ├── afs-adapter.ts                        — AFS: HTML scraping strategy
  ├── pdf-adapter-base.ts                   — Shared PDF comparison logic
  ├── nfs-adapter.ts                        — NFS: extends PDF base
  └── msbfs-adapter.ts                      — MSBFS: extends PDF base

lib/agency/
  ├── afs-scraper.ts                        — Existing (reused by AFS adapter)
  ├── afs-html-transformer.ts               — Existing (reused by AFS adapter)
  ├── agency-pdf-registry.ts                — Document URLs (input for adapters)
  └── afs-registry.ts                       — AFS document list
```

### Agency Website Structures (Research Notes)

**AFS (av.se):**
- Regulations at: `https://www.av.se/arbetsmiljoarbete-och-inspektioner/publikationer/foreskrifter/`
- Each regulation has a page URL like: `https://www.av.se/.../{slug}/`
- Content in `div.provision` container
- HTML scraping proven in Story 9.1
- Change detection: compare scraped HTML hash

**NFS (naturvardsverket.se):**
- Regulations at: `https://www.naturvardsverket.se/lagar-och-regler/foreskrifter-och-allmanna-rad/`
- Each regulation has a landing page with PDF download link
- Change detection: check if PDF URL or "Senast uppdaterad" date changed

**MSBFS (mcf.se):**
- Regulations at: `https://www.mcf.se/sv/regler/gallande-regler/`
- Each regulation has a landing page at `mcf.se/sv/regler/gallande-regler/{slug}/`
- PDF link embedded in page
- Change detection: check PDF URL or page content

### Adapter Pattern Example

```typescript
// lib/agency/adapters/afs-adapter.ts
import { AgencyAdapter, AgencyUpdateResult, DocumentContent } from './types'
import { scrapeAfsRegulation } from '../afs-scraper'
import { transformAfsHtml } from '../afs-html-transformer'
import { createHash } from 'crypto'

export class AfsAdapter implements AgencyAdapter {
  agencyCode = 'afs' as const
  displayName = 'Arbetsmiljooverket (AFS)'

  async checkForUpdates(): Promise<AgencyUpdateResult[]> {
    const updates: AgencyUpdateResult[] = []

    // Get all AFS documents from DB with stored content hashes
    const docs = await prisma.legalDocument.findMany({
      where: {
        content_type: 'AGENCY_REGULATION',
        document_number: { startsWith: 'AFS' }
      },
      select: { document_number: true, metadata: true, source_url: true }
    })

    for (const doc of docs) {
      const stored = doc.metadata as { contentHash?: string, pageUrl?: string }
      if (!stored?.pageUrl) continue

      try {
        const scraped = await scrapeAfsRegulation(stored.pageUrl)
        const newHash = createHash('sha256').update(scraped.html).digest('hex')

        if (newHash !== stored.contentHash) {
          updates.push({
            documentNumber: doc.document_number,
            changeType: 'UPDATED',
            currentUrl: stored.pageUrl,
            detectedAt: new Date(),
            details: `Content hash changed (old: ${stored.contentHash?.slice(0, 8)}..., new: ${newHash.slice(0, 8)}...)`
          })
        }
      } catch (err) {
        console.warn(`AFS adapter: failed to check ${doc.document_number}:`, err)
      }
    }

    return updates
  }

  async fetchDocumentContent(documentNumber: string): Promise<DocumentContent | null> {
    // Fetch, scrape, transform, return
    // ...
  }
}
```

### Content Hash Comparison

```typescript
import { createHash } from 'crypto'

function computeContentHash(html: string): string {
  // Normalize HTML before hashing to avoid false positives from whitespace changes
  const normalized = html.replace(/\s+/g, ' ').trim()
  return createHash('sha256').update(normalized).digest('hex')
}
```

### Rate Limiting

```typescript
import pLimit from 'p-limit'

const limit = pLimit(5) // Max 5 concurrent requests per agency
const results = await Promise.all(
  documents.map(doc => limit(() => checkDocument(doc)))
)
```

## Testing

**Test location:** `lib/agency/adapters/__tests__/`

**Test framework:** Vitest with `vi.mock()` for fetch, Prisma

**Unit tests:**
- AFS adapter: given document with changed content hash → returns UPDATED
- AFS adapter: given document with same content hash → returns empty
- AFS adapter: network error → returns empty, logs warning
- PDF base adapter: changed PDF URL detected → returns UPDATED
- PDF base adapter: new document on listing page → returns NEW
- Registry: `getAdapter('afs')` returns AFS adapter instance
- Registry: `getAdapter('unknown')` returns null
- Registry: `getImplementedAdapters()` returns list of implemented codes
- Rate limiting: concurrent requests capped at 5

**Integration test (manual):**
```typescript
import { getAdapter } from '@/lib/agency/adapters'

const afs = getAdapter('afs')
const updates = await afs?.checkForUpdates()
console.log('AFS updates:', updates)
// → [] if no changes, or [{documentNumber, changeType, ...}] if changed
```

## Change Log

| Date       | Version | Description                  | Author     |
| ---------- | ------- | ---------------------------- | ---------- |
| 2026-02-17 | 1.0     | Initial story creation       | Sarah (PO) |

## Dev Agent Record

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
