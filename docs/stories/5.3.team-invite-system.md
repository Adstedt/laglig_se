# Story 5.3: Build Team Invite System (Settings UI)

## Status

Draft

## Story

**As a** workspace owner/admin,
**I want** to invite team members via email from the team settings page,
**so that** they can join my workspace without me sharing a link manually.

## Context & Dependencies

- **Builds on:** Story 10.3 (completed) — which delivered the `WorkspaceInvitation` Prisma model, token-based invitation system, `InvitationStatus` enum, and the onboarding acceptance flow
- **Builds on:** Story 5.2 (completed) — role-based permissions (`members:invite`, `members:remove`, `members:change_role`)
- **Builds on:** Story 5.7 (completed) — workspace settings page shell
- **Builds on:** Story 0.1 (completed) — email infrastructure (Resend + React Email)
- **Depends on:** None (all prerequisites completed)
- **Note:** Story 10.3 handles invitation acceptance during onboarding. This story adds the **sending** side — inviting from within the workspace settings UI.

## Acceptance Criteria

1. Team settings page (`/settings/team`) shows current workspace members list with name, email, role, and join date
2. "Bjud in medlem" button visible only to users with `members:invite` permission
3. Invite modal with fields: Email, Role (dropdown: Member, HR Manager, Admin)
4. Clicking "Skicka inbjudan" creates a `WorkspaceInvitation` record using the existing model from 10.3
5. Invitation email sent via Resend with: workspace name, inviter name, role, and "Acceptera inbjudan" CTA link
6. Invite link format: `/invite/[token]` (uses existing 10.3 acceptance flow)
7. Pending invitations shown below member list with email, role, invited date, and expiry countdown
8. Owner/Admin can re-send invites (resets expiry) or revoke pending invites
9. Invite expiry: 7 days, Vercel cron job cleans up expired invitations daily
10. Duplicate prevention: cannot invite email that is already a member or has a pending invitation

## Tasks / Subtasks

- [ ] Add members list with role display to team settings page
- [ ] Build "Bjud in medlem" modal component
- [ ] Create invitation API endpoint (`POST /api/workspace/invitations`)
- [ ] Create React Email template for workspace invitation
- [ ] Show pending invitations section below members
- [ ] Implement re-send invitation endpoint (`POST /api/workspace/invitations/[id]/resend`)
- [ ] Implement revoke invitation endpoint (`DELETE /api/workspace/invitations/[id]`)
- [ ] Create Vercel cron route for expired invitation cleanup
- [ ] Test complete invite flow end-to-end

## Dev Notes

**Existing infrastructure (from 10.3 — DO NOT recreate):**

The `WorkspaceInvitation` model already exists in `prisma/schema.prisma`:

```prisma
model WorkspaceInvitation {
  id           String           @id @default(uuid())
  workspace_id String
  email        String
  role         WorkspaceRole    @default(MEMBER)
  token        String           @unique
  invited_by   String
  status       InvitationStatus @default(PENDING)
  expires_at   DateTime
  created_at   DateTime         @default(now())
  updated_at   DateTime         @updatedAt

  workspace Workspace @relation(fields: [workspace_id], references: [id], onDelete: Cascade)
  inviter   User      @relation("InvitationInviter", fields: [invited_by], references: [id])

  @@index([email])
  @@index([workspace_id])
  @@index([token])
  @@map("workspace_invitations")
}
```

**Invitation API Endpoint:**

```typescript
// app/api/workspace/invitations/route.ts
import crypto from 'crypto'
import { NextResponse } from 'next/server'
import { getWorkspaceContext } from '@/lib/auth/workspace-context'
import { requirePermission } from '@/lib/api/require-permission'
import { prisma } from '@/lib/prisma'
import { sendEmail } from '@/lib/email/email-service'
import { WorkspaceInvitationEmail } from '@/components/emails/workspace-invitation'

export async function POST(request: Request) {
  const denied = await requirePermission('members:invite')
  if (denied) return denied

  const context = await getWorkspaceContext()
  const { email, role } = await request.json()

  // Validate: not already a member
  const existingMember = await prisma.workspaceMember.findFirst({
    where: { workspace_id: context.workspaceId, user: { email } },
  })
  if (existingMember) {
    return NextResponse.json({ error: 'Användaren är redan medlem' }, { status: 400 })
  }

  // Validate: no pending invitation
  const existingInvitation = await prisma.workspaceInvitation.findFirst({
    where: { workspace_id: context.workspaceId, email, status: 'PENDING' },
  })
  if (existingInvitation) {
    return NextResponse.json({ error: 'Inbjudan redan skickad' }, { status: 400 })
  }

  // Create invitation (reuse 10.3 model)
  const token = crypto.randomBytes(32).toString('base64url')
  const invitation = await prisma.workspaceInvitation.create({
    data: {
      workspace_id: context.workspaceId,
      email,
      role,
      token,
      invited_by: context.userId,
      expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    },
  })

  // Send invitation email via Resend
  await sendEmail({
    to: email,
    subject: `Inbjudan till ${context.workspaceName} på Laglig.se`,
    react: WorkspaceInvitationEmail({
      workspaceName: context.workspaceName,
      inviterEmail: '', // Resolved from context.userId
      role,
      inviteUrl: `${process.env.NEXT_PUBLIC_APP_URL}/invite/${token}`,
    }),
    from: 'notifications',
  })

  return NextResponse.json({ success: true, id: invitation.id })
}

// GET: List current members + pending invitations
export async function GET() {
  const context = await getWorkspaceContext()

  const [members, invitations] = await Promise.all([
    prisma.workspaceMember.findMany({
      where: { workspace_id: context.workspaceId },
      include: { user: { select: { id: true, email: true, name: true } } },
      orderBy: { joined_at: 'asc' },
    }),
    prisma.workspaceInvitation.findMany({
      where: { workspace_id: context.workspaceId, status: 'PENDING' },
      orderBy: { created_at: 'desc' },
    }),
  ])

  return NextResponse.json({ members, invitations })
}
```

**Revoke / Resend Endpoints:**

```typescript
// app/api/workspace/invitations/[id]/route.ts
export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  const denied = await requirePermission('members:invite')
  if (denied) return denied

  const context = await getWorkspaceContext()

  await prisma.workspaceInvitation.updateMany({
    where: { id: params.id, workspace_id: context.workspaceId, status: 'PENDING' },
    data: { status: 'REVOKED' },
  })

  return NextResponse.json({ success: true })
}

// app/api/workspace/invitations/[id]/resend/route.ts
export async function POST(request: Request, { params }: { params: { id: string } }) {
  const denied = await requirePermission('members:invite')
  if (denied) return denied

  const context = await getWorkspaceContext()

  const invitation = await prisma.workspaceInvitation.findFirst({
    where: { id: params.id, workspace_id: context.workspaceId, status: 'PENDING' },
  })
  if (!invitation) {
    return NextResponse.json({ error: 'Inbjudan hittades inte' }, { status: 404 })
  }

  // Reset expiry
  await prisma.workspaceInvitation.update({
    where: { id: invitation.id },
    data: { expires_at: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) },
  })

  // Re-send email
  await sendEmail({
    to: invitation.email,
    subject: `Påminnelse: Inbjudan till ${context.workspaceName} på Laglig.se`,
    react: WorkspaceInvitationEmail({
      workspaceName: context.workspaceName,
      inviterEmail: '',
      role: invitation.role,
      inviteUrl: `${process.env.NEXT_PUBLIC_APP_URL}/invite/${invitation.token}`,
    }),
    from: 'notifications',
  })

  return NextResponse.json({ success: true })
}
```

**Expired Invitation Cleanup (Vercel Cron):**

```typescript
// app/api/cron/cleanup-invitations/route.ts
export const dynamic = 'force-dynamic'
export const maxDuration = 60

const CRON_SECRET = process.env.CRON_SECRET

export async function GET(request: Request) {
  const authHeader = request.headers.get('authorization')
  if (process.env.NODE_ENV !== 'development' && CRON_SECRET && authHeader !== `Bearer ${CRON_SECRET}`) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const result = await prisma.workspaceInvitation.updateMany({
    where: {
      status: 'PENDING',
      expires_at: { lt: new Date() },
    },
    data: { status: 'EXPIRED' },
  })

  console.log(`[CLEANUP-INVITATIONS] Expired ${result.count} invitations`)

  return NextResponse.json({ success: true, expired: result.count })
}
```

Add to `vercel.json`:
```json
{
  "crons": [
    { "path": "/api/cron/cleanup-invitations", "schedule": "0 2 * * *" }
  ]
}
```

**Reference:** Story 10.3 (invitation model), Story 5.2 (permissions), `lib/auth/workspace-context.ts`, `lib/email/email-service.ts`

## Testing

**Unit Tests:**

- Token generation creates unique, URL-safe tokens
- Invitation expiry calculated correctly (7 days)
- Duplicate member detection blocks invite
- Duplicate pending invitation detection blocks invite

**Integration Tests:**

- Complete invite flow: send invitation, verify record created with PENDING status
- Revoke invitation: status changes to REVOKED
- Resend invitation: expiry date reset, email sent
- Expired invitation cleanup cron marks old invitations as EXPIRED
- Acceptance still works via 10.3 flow after sending from settings

**Test File:** `tests/unit/api/workspace-invitations.test.ts`

## Change Log

| Date       | Version | Description                                                 | Author     |
| ---------- | ------- | ----------------------------------------------------------- | ---------- |
| 2025-11-12 | 1.0     | Initial story creation                                      | Sarah (PO) |
| 2026-02-19 | 2.0     | Rewritten as delta on 10.3, updated auth/email/cron patterns | Sarah (PO) |

## Dev Agent Record

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
