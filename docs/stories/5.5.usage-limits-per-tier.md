# Story 5.5: Implement Usage Limits Per Tier

## Status

Draft

## Story

**As a** system,
**I want** to enforce usage limits based on subscription tier,
**so that** users must upgrade when they exceed limits.

## Acceptance Criteria

1. Usage limits defined per tier:
   - Solo: 1 user, 5 employees, 50 AI queries/month, 1GB storage
   - Team: 5 users, 50 employees, 500 AI queries/month, 10GB storage
   - Enterprise: Unlimited users, unlimited employees, unlimited queries, 100GB storage
2. Usage tracked in database: `workspace_usage` table with fields: ai_queries_this_month, employee_count, storage_used_mb
3. Middleware checks usage before allowing actions:
   - Adding user → Check user limit
   - Adding employee → Check employee limit
   - Sending AI query → Check query limit
   - Uploading file → Check storage limit
4. 10% overage allowance before hard block
5. Soft limit warning at 80%: "You've used 40/50 AI queries this month. Upgrade?"
6. Hard limit at 110%: "You've reached your limit. Upgrade to continue."
7. Usage resets monthly (1st of month)
8. Analytics dashboard shows usage trends

## Tasks / Subtasks

- [ ] Define usage limits per tier
- [ ] Create workspace_usage table
- [ ] Implement usage tracking for AI queries
- [ ] Implement usage tracking for employees
- [ ] Implement usage tracking for storage
- [ ] Create usage check middleware
- [ ] Add soft limit warnings (80%)
- [ ] Add hard limit blocks (110%)
- [ ] Implement monthly reset cron job
- [ ] Build usage dashboard
- [ ] Test all usage scenarios

## Dev Notes

**Usage Limits Definition:**

```typescript
// lib/usage/limits.ts

export interface UsageLimits {
  users: number | null // null = unlimited
  employees: number | null
  aiQueriesPerMonth: number | null
  storageGB: number | null
}

export const TIER_LIMITS: Record<string, UsageLimits> = {
  trial: {
    users: 1,
    employees: 5,
    aiQueriesPerMonth: 50,
    storageGB: 1,
  },
  solo: {
    users: 1,
    employees: 5,
    aiQueriesPerMonth: 50,
    storageGB: 1,
  },
  team: {
    users: 5,
    employees: 50,
    aiQueriesPerMonth: 500,
    storageGB: 10,
  },
  enterprise: {
    users: null, // unlimited
    employees: null,
    aiQueriesPerMonth: null,
    storageGB: 100,
  },
}

export function getLimits(tier: string): UsageLimits {
  return TIER_LIMITS[tier] || TIER_LIMITS.solo
}

export function isUnlimited(limit: number | null): boolean {
  return limit === null
}

export function calculateUsagePercentage(
  current: number,
  limit: number | null
): number {
  if (isUnlimited(limit)) return 0
  return (current / limit!) * 100
}

export function hasReachedSoftLimit(
  current: number,
  limit: number | null
): boolean {
  if (isUnlimited(limit)) return false
  return calculateUsagePercentage(current, limit) >= 80
}

export function hasReachedHardLimit(
  current: number,
  limit: number | null
): boolean {
  if (isUnlimited(limit)) return false
  return calculateUsagePercentage(current, limit) >= 110
}
```

**Database Schema:**

```prisma
model WorkspaceUsage {
  id                  String   @id @default(uuid())
  workspaceId         String   @unique
  aiQueriesThisMonth  Int      @default(0)
  employeeCount       Int      @default(0)
  storageUsedMb       Int      @default(0)
  lastResetAt         DateTime @default(now())
  updatedAt           DateTime @updatedAt

  workspace Workspace @relation(fields: [workspaceId], references: [id], onDelete: Cascade)

  @@map("workspace_usage")
}
```

**Usage Tracking Functions:**

```typescript
// lib/usage/track.ts

export async function trackAIQuery(workspaceId: string) {
  await prisma.workspaceUsage.upsert({
    where: { workspaceId },
    update: {
      aiQueriesThisMonth: {
        increment: 1,
      },
    },
    create: {
      workspaceId,
      aiQueriesThisMonth: 1,
    },
  })
}

export async function trackEmployeeCount(workspaceId: string) {
  const count = await prisma.employee.count({
    where: { workspaceId },
  })

  await prisma.workspaceUsage.upsert({
    where: { workspaceId },
    update: { employeeCount: count },
    create: {
      workspaceId,
      employeeCount: count,
    },
  })
}

export async function trackStorageUsage(
  workspaceId: string,
  fileSizeMb: number
) {
  await prisma.workspaceUsage.upsert({
    where: { workspaceId },
    update: {
      storageUsedMb: {
        increment: fileSizeMb,
      },
    },
    create: {
      workspaceId,
      storageUsedMb: fileSizeMb,
    },
  })
}

export async function getCurrentUsage(workspaceId: string) {
  const usage = await prisma.workspaceUsage.findUnique({
    where: { workspaceId },
  })

  if (!usage) {
    return {
      aiQueriesThisMonth: 0,
      employeeCount: 0,
      storageUsedMb: 0,
    }
  }

  return usage
}
```

**Usage Check Middleware:**

```typescript
// lib/usage/check.ts

export class UsageLimitError extends Error {
  constructor(
    public limitType: 'users' | 'employees' | 'aiQueries' | 'storage',
    public current: number,
    public limit: number,
    public isHardLimit: boolean
  ) {
    super(`Usage limit reached for ${limitType}`)
  }
}

export async function checkUsageLimit(
  workspaceId: string,
  limitType: 'users' | 'employees' | 'aiQueries' | 'storage',
  additionalUsage: number = 1
): Promise<{ allowed: boolean; warning?: string }> {
  const workspace = await prisma.workspace.findUnique({
    where: { id: workspaceId },
    include: { usage: true },
  })

  if (!workspace) {
    throw new Error('Workspace not found')
  }

  const limits = getLimits(workspace.subscriptionTier)
  const usage = workspace.usage || {
    aiQueriesThisMonth: 0,
    employeeCount: 0,
    storageUsedMb: 0,
  }

  let currentUsage: number
  let limit: number | null

  switch (limitType) {
    case 'users':
      currentUsage = await prisma.workspaceMember.count({
        where: { workspaceId },
      })
      limit = limits.users
      break

    case 'employees':
      currentUsage = usage.employeeCount
      limit = limits.employees
      break

    case 'aiQueries':
      currentUsage = usage.aiQueriesThisMonth
      limit = limits.aiQueriesPerMonth
      break

    case 'storage':
      currentUsage = usage.storageUsedMb / 1024 // Convert to GB
      limit = limits.storageGB
      break
  }

  // Unlimited
  if (isUnlimited(limit)) {
    return { allowed: true }
  }

  const futureUsage = currentUsage + additionalUsage

  // Hard limit (110%)
  if (futureUsage > limit! * 1.1) {
    throw new UsageLimitError(limitType, currentUsage, limit!, true)
  }

  // Soft limit warning (80%)
  if (futureUsage >= limit! * 0.8 && currentUsage < limit! * 0.8) {
    return {
      allowed: true,
      warning: `You've used ${currentUsage}/${limit} ${limitType}. Consider upgrading your plan.`,
    }
  }

  return { allowed: true }
}
```

**Usage Check in API Routes:**

```typescript
// app/api/chat/query/route.ts
export async function POST(request: Request) {
  return withWorkspace(async ({ workspaceId }) => {
    // Check AI query limit
    try {
      const usageCheck = await checkUsageLimit(workspaceId, 'aiQueries')

      // Track the query
      await trackAIQuery(workspaceId)

      // Process the query
      const { query } = await request.json()
      const answer = await generateAIAnswer(query, workspaceId)

      return NextResponse.json({
        answer,
        warning: usageCheck.warning,
      })
    } catch (error) {
      if (error instanceof UsageLimitError) {
        return NextResponse.json(
          {
            error: 'Usage limit reached',
            message: `You've reached your ${error.limitType} limit of ${error.limit}. Please upgrade your plan to continue.`,
            limitType: error.limitType,
            current: error.current,
            limit: error.limit,
          },
          { status: 429 }
        )
      }

      throw error
    }
  })
}
```

**Usage Dashboard Component:**

```typescript
// components/usage/usage-dashboard.tsx
'use client'

import { useEffect, useState } from 'react'

export function UsageDashboard() {
  const [usage, setUsage] = useState<any>(null)
  const [limits, setLimits] = useState<any>(null)

  useEffect(() => {
    async function fetchUsage() {
      const response = await fetch('/api/usage')
      const data = await response.json()
      setUsage(data.usage)
      setLimits(data.limits)
    }

    fetchUsage()
  }, [])

  if (!usage || !limits) return <div>Loading...</div>

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      <UsageCard
        title="Team Members"
        current={usage.userCount}
        limit={limits.users}
        unit="users"
      />
      <UsageCard
        title="Employees"
        current={usage.employeeCount}
        limit={limits.employees}
        unit="employees"
      />
      <UsageCard
        title="AI Queries"
        current={usage.aiQueriesThisMonth}
        limit={limits.aiQueriesPerMonth}
        unit="queries"
        resetText="Resets monthly"
      />
      <UsageCard
        title="Storage"
        current={usage.storageUsedMb / 1024}
        limit={limits.storageGB}
        unit="GB"
      />
    </div>
  )
}

function UsageCard({
  title,
  current,
  limit,
  unit,
  resetText
}: {
  title: string
  current: number
  limit: number | null
  unit: string
  resetText?: string
}) {
  const isUnlimited = limit === null
  const percentage = isUnlimited ? 0 : (current / limit) * 100
  const isWarning = percentage >= 80
  const isDanger = percentage >= 100

  return (
    <div className="bg-white rounded-lg shadow p-6">
      <h3 className="text-sm font-medium text-gray-600 mb-2">{title}</h3>

      <div className="mb-4">
        <p className="text-3xl font-bold">
          {current.toFixed(0)}
          {!isUnlimited && <span className="text-lg text-gray-500">/{limit}</span>}
        </p>
        <p className="text-sm text-gray-600">
          {isUnlimited ? 'Unlimited' : `${unit}`}
        </p>
      </div>

      {!isUnlimited && (
        <>
          {/* Progress bar */}
          <div className="h-2 bg-gray-200 rounded-full overflow-hidden mb-2">
            <div
              className={`h-full transition-all ${
                isDanger
                  ? 'bg-red-500'
                  : isWarning
                  ? 'bg-yellow-500'
                  : 'bg-green-500'
              }`}
              style={{ width: `${Math.min(percentage, 100)}%` }}
            />
          </div>

          <p className="text-xs text-gray-600">
            {percentage.toFixed(0)}% used
            {resetText && ` • ${resetText}`}
          </p>

          {isWarning && (
            <p className="mt-2 text-xs text-yellow-600">
              ⚠️ Consider upgrading
            </p>
          )}

          {isDanger && (
            <p className="mt-2 text-xs text-red-600">
              ❌ Limit reached
            </p>
          )}
        </>
      )}
    </div>
  )
}
```

**Monthly Reset Cron Job:**

```typescript
// lib/cron/reset-usage.ts
import cron from 'node-cron'

export function scheduleMonthlyUsageReset() {
  // Run on 1st of every month at 00:00 UTC
  cron.schedule('0 0 1 * *', async () => {
    console.log('Resetting monthly usage...')

    await prisma.workspaceUsage.updateMany({
      data: {
        aiQueriesThisMonth: 0,
        lastResetAt: new Date(),
      },
    })

    console.log('Monthly usage reset complete')
  })
}
```

**Usage API Endpoint:**

```typescript
// app/api/usage/route.ts
export async function GET(request: Request) {
  return withWorkspace(async ({ workspaceId, workspace }) => {
    const usage = await getCurrentUsage(workspaceId)
    const limits = getLimits(workspace.subscriptionTier)

    const userCount = await prisma.workspaceMember.count({
      where: { workspaceId },
    })

    return NextResponse.json({
      usage: {
        ...usage,
        userCount,
      },
      limits,
      tier: workspace.subscriptionTier,
    })
  })
}
```

**Upgrade Prompt Component:**

```typescript
// components/usage/upgrade-prompt.tsx
export function UpgradePrompt({
  limitType,
  current,
  limit
}: {
  limitType: string
  current: number
  limit: number
}) {
  return (
    <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
      <div className="flex items-start">
        <svg
          className="w-5 h-5 text-yellow-600 mr-3 mt-0.5"
          fill="currentColor"
          viewBox="0 0 20 20"
        >
          <path
            fillRule="evenodd"
            d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"
            clipRule="evenodd"
          />
        </svg>
        <div className="flex-1">
          <h3 className="text-sm font-semibold text-yellow-900">
            Usage Limit Reached
          </h3>
          <p className="text-sm text-yellow-800 mt-1">
            You've used {current}/{limit} {limitType}. Upgrade your plan to
            continue.
          </p>
          <button
            onClick={() => (window.location.href = '/billing/upgrade')}
            className="mt-3 px-4 py-2 bg-yellow-600 text-white rounded-lg text-sm hover:bg-yellow-700"
          >
            Upgrade Now
          </button>
        </div>
      </div>
    </div>
  )
}
```

**Reference:** PRD Epic 5 Story 5.5, Architecture Section 14 (Subscription Management)

## Testing

**Unit Tests:**

- `calculateUsagePercentage()` returns correct percentage
- `hasReachedSoftLimit()` returns true at 80%
- `hasReachedHardLimit()` returns true at 110%
- Unlimited limits return false for limit checks

**Integration Tests:**

- Add employee when at limit (should block)
- Send AI query when at limit (should block)
- Add employee at 79% (should succeed with warning)
- Monthly reset clears AI query count
- Enterprise tier has no limits

**Manual Testing:**

- Create Solo workspace, add 5 employees (should work)
- Try to add 6th employee (should block)
- Send 50 AI queries in Solo tier (should work)
- Try 51st query (should block)
- Upgrade to Team tier, verify limits increase
- Test monthly reset (mock date to 1st of month)

**Load Testing:**

- Usage tracking doesn't slow down API requests
- Concurrent usage checks don't cause race conditions

**Test File:** `__tests__/features/usage/limits.test.ts`

## User vs Developer Responsibilities

**User Responsibility:**

- Monitor usage dashboard
- Upgrade plan when approaching limits
- Understand tier limitations before choosing plan

**Developer Responsibility:**

- Track all usage accurately
- Enforce limits at API level
- Provide clear warning at 80% usage
- Block at 110% (with 10% overage grace)
- Reset usage monthly
- Display usage dashboard clearly
- Test edge cases (exactly at limit, etc.)

## Change Log

| Date       | Version | Description            | Author     |
| ---------- | ------- | ---------------------- | ---------- |
| 2025-11-12 | 1.0     | Initial story creation | Sarah (PO) |

## Dev Agent Record

_To be populated by dev agent_

## QA Results

_To be populated by QA agent_
